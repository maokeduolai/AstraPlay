<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AstraPlay: F:/QtProject/AstraPlay/src/include/mpv/client.h 文件参考</title>
<link rel="icon" href="AstraPlay_Logo_Small.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="AstraPlay_Logo_Small.png"/></td>
  <td id="projectalign">
   <div id="projectname">AstraPlay<span id="projectnumber">&#160;v1.0.2</span>
   </div>
   <div id="projectbrief">基于libmpv与Qt5框架的视频播放器</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.10.0 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>首页</span></a></li>
      <li><a href="pages.html"><span>相关页面</span></a></li>
      <li><a href="namespaces.html"><span>命名空间</span></a></li>
      <li><a href="annotated.html"><span>类</span></a></li>
      <li class="current"><a href="files.html"><span>文件</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>文件列表</span></a></li>
      <li><a href="globals.html"><span>文件成员</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_b0856f6b0d80ccb263b2f415c91f9e17.html">include</a></li><li class="navelem"><a class="el" href="dir_85e4b8678a4e308299dd4557438491b5.html">mpv</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">类</a> &#124;
<a href="#define-members">宏定义</a> &#124;
<a href="#typedef-members">类型定义</a> &#124;
<a href="#enum-members">枚举</a> &#124;
<a href="#func-members">函数</a>  </div>
  <div class="headertitle"><div class="title">client.h 文件参考</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
client.h 的引用(Include)关系图:</div>
<div class="dyncontent">
<div class="center"><img src="client_8h__incl.png" border="0" usemap="#a_f_1_2_qt_project_2_astra_play_2src_2include_2mpv_2client_8h" alt=""/></div>
<map name="a_f_1_2_qt_project_2_astra_play_2src_2include_2mpv_2client_8h" id="a_f_1_2_qt_project_2_astra_play_2src_2include_2mpv_2client_8h">
<area shape="rect" title=" " alt="" coords="5,5,167,48"/>
<area shape="rect" title=" " alt="" coords="8,96,76,123"/>
<area shape="poly" title=" " alt="" coords="77,50,59,83,54,81,72,47"/>
<area shape="rect" title=" " alt="" coords="99,96,164,123"/>
<area shape="poly" title=" " alt="" coords="100,47,119,81,114,84,95,50"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
此图展示该文件直接或间接的被哪些文件引用了:</div>
<div class="dyncontent">
<div class="center"><img src="client_8h__dep__incl.png" border="0" usemap="#a_f_1_2_qt_project_2_astra_play_2src_2include_2mpv_2client_8hdep" alt=""/></div>
<map name="a_f_1_2_qt_project_2_astra_play_2src_2include_2mpv_2client_8hdep" id="a_f_1_2_qt_project_2_astra_play_2src_2include_2mpv_2client_8hdep">
<area shape="rect" title=" " alt="" coords="331,5,492,48"/>
<area shape="rect" href="controller_8h.html" title=" " alt="" coords="73,187,230,229"/>
<area shape="poly" title=" " alt="" coords="316,35,278,42,240,54,205,73,175,98,162,118,155,142,152,186,147,186,149,141,157,116,171,94,202,68,238,50,277,37,315,30"/>
<area shape="rect" href="qthelper_8hpp.html" title=" " alt="" coords="184,96,375,139"/>
<area shape="poly" title=" " alt="" coords="369,59,312,98,309,93,366,55"/>
<area shape="rect" href="subtitle_8h.html" title=" " alt="" coords="261,187,415,229"/>
<area shape="poly" title=" " alt="" coords="409,64,402,101,388,140,374,166,358,188,353,185,369,163,384,138,396,100,404,63"/>
<area shape="rect" href="render_8h.html" title=" " alt="" coords="448,96,615,139"/>
<area shape="poly" title=" " alt="" coords="453,55,505,93,502,98,449,59"/>
<area shape="rect" href="stream__cb_8h.html" title=" " alt="" coords="638,96,830,139"/>
<area shape="poly" title=" " alt="" coords="502,50,659,93,658,98,501,55"/>
<area shape="rect" href="controller_8cpp.html" title=" " alt="" coords="5,459,159,501"/>
<area shape="poly" title=" " alt="" coords="88,240,65,257,46,279,27,312,20,342,22,373,32,410,46,435,63,457,58,460,41,438,28,412,17,374,15,341,22,310,41,276,61,253,85,235"/>
<area shape="rect" href="application_8h.html" title=" " alt="" coords="255,368,421,411"/>
<area shape="poly" title=" " alt="" coords="206,235,235,254,261,275,301,322,329,366,324,369,297,325,257,279,231,258,203,240"/>
<area shape="rect" href="screen__capture_8h.html" title=" " alt="" coords="55,277,248,320"/>
<area shape="poly" title=" " alt="" coords="154,245,154,277,149,277,149,245"/>
<area shape="poly" title=" " alt="" coords="264,419,143,461,141,455,263,414"/>
<area shape="rect" href="application_8cpp.html" title=" " alt="" coords="399,459,552,501"/>
<area shape="poly" title=" " alt="" coords="384,417,445,456,442,460,381,422"/>
<area shape="rect" href="main_8cpp.html" title=" " alt="" coords="221,459,375,501"/>
<area shape="poly" title=" " alt="" coords="325,426,310,459,305,457,320,424"/>
<area shape="poly" title=" " alt="" coords="210,325,296,365,293,370,207,329"/>
<area shape="rect" href="screen__capture_8cpp.html" title=" " alt="" coords="42,368,231,411"/>
<area shape="poly" title=" " alt="" coords="148,336,143,368,137,367,143,335"/>
<area shape="poly" title=" " alt="" coords="239,150,183,188,180,184,236,145"/>
<area shape="poly" title=" " alt="" coords="304,150,327,185,322,188,299,153"/>
<area shape="poly" title=" " alt="" coords="341,245,341,368,335,368,335,245"/>
<area shape="rect" href="subtitle_8cpp.html" title=" " alt="" coords="376,277,529,320"/>
<area shape="poly" title=" " alt="" coords="378,237,427,275,424,279,375,241"/>
<area shape="rect" href="render__gl_8h.html" title=" " alt="" coords="440,187,623,229"/>
<area shape="poly" title=" " alt="" coords="534,154,534,186,529,186,529,154"/>
</map>
</div>
</div>
<p><a href="client_8h_source.html">浏览源代码.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
类</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpv__node.html">mpv_node</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpv__node__list.html">mpv_node_list</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpv__byte__array.html">mpv_byte_array</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpv__event__property.html">mpv_event_property</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpv__event__log__message.html">mpv_event_log_message</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpv__event__start__file.html">mpv_event_start_file</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Since API version 1.108.  <a href="structmpv__event__start__file.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpv__event__end__file.html">mpv_event_end_file</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpv__event__client__message.html">mpv_event_client_message</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpv__event__hook.html">mpv_event_hook</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpv__event__command.html">mpv_event_command</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpv__event.html">mpv_event</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
宏定义</h2></td></tr>
<tr class="memitem:a645bac051595e752c4527981767d1604" id="r_a645bac051595e752c4527981767d1604"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a></td></tr>
<tr class="separator:a645bac051595e752c4527981767d1604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a987fd04fa0aa4df3e3af33f9f41a18da" id="r_a987fd04fa0aa4df3e3af33f9f41a18da"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a987fd04fa0aa4df3e3af33f9f41a18da">MPV_SELECTANY</a></td></tr>
<tr class="separator:a987fd04fa0aa4df3e3af33f9f41a18da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae292682d85e3c5efe48447ee8fa04f2c" id="r_ae292682d85e3c5efe48447ee8fa04f2c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae292682d85e3c5efe48447ee8fa04f2c">MPV_DECLTYPE</a>&#160;&#160;&#160;__typeof__</td></tr>
<tr class="separator:ae292682d85e3c5efe48447ee8fa04f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9935d5ba969afe3bd22bb67e2759a1" id="r_a8f9935d5ba969afe3bd22bb67e2759a1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f9935d5ba969afe3bd22bb67e2759a1">MPV_MAKE_VERSION</a>(major,  minor)&#160;&#160;&#160;(((major) &lt;&lt; 16) | (minor) | 0UL)</td></tr>
<tr class="separator:a8f9935d5ba969afe3bd22bb67e2759a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91cbe68751252981e05719088d7cb3b0" id="r_a91cbe68751252981e05719088d7cb3b0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91cbe68751252981e05719088d7cb3b0">MPV_CLIENT_API_VERSION</a>&#160;&#160;&#160;<a class="el" href="#a8f9935d5ba969afe3bd22bb67e2759a1">MPV_MAKE_VERSION</a>(2, 2)</td></tr>
<tr class="separator:a91cbe68751252981e05719088d7cb3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a668c00e17d4fe9298a8a72cd535a74a7" id="r_a668c00e17d4fe9298a8a72cd535a74a7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a668c00e17d4fe9298a8a72cd535a74a7">MPV_ENABLE_DEPRECATED</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a668c00e17d4fe9298a8a72cd535a74a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
类型定义</h2></td></tr>
<tr class="memitem:a93d313a21048fe10f1edd9b03e05d416" id="r_a93d313a21048fe10f1edd9b03e05d416"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a></td></tr>
<tr class="separator:a93d313a21048fe10f1edd9b03e05d416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc7e04d0d96db37a2c3dbf8b5cd2d76" id="r_aefc7e04d0d96db37a2c3dbf8b5cd2d76"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="#ae3ecabf6277821768141a86e5fad779f">mpv_error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aefc7e04d0d96db37a2c3dbf8b5cd2d76">mpv_error</a></td></tr>
<tr class="separator:aefc7e04d0d96db37a2c3dbf8b5cd2d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f07dc2039f1f12f018a803c40d3fdd5" id="r_a6f07dc2039f1f12f018a803c40d3fdd5"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="#a8de0a5cfaeed2adfe0c344df68ba292f">mpv_format</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f07dc2039f1f12f018a803c40d3fdd5">mpv_format</a></td></tr>
<tr class="separator:a6f07dc2039f1f12f018a803c40d3fdd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193131c36f988b34d2b3808930d6fe2b" id="r_a193131c36f988b34d2b3808930d6fe2b"><td class="memItemLeft" align="right" valign="top">typedef struct mpv_node&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a193131c36f988b34d2b3808930d6fe2b">mpv_node</a></td></tr>
<tr class="separator:a193131c36f988b34d2b3808930d6fe2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd793adbb96bc3dd85572dbbf242f2a6" id="r_abd793adbb96bc3dd85572dbbf242f2a6"><td class="memItemLeft" align="right" valign="top">typedef struct mpv_node_list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd793adbb96bc3dd85572dbbf242f2a6">mpv_node_list</a></td></tr>
<tr class="separator:abd793adbb96bc3dd85572dbbf242f2a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab81c48c60fc42fdd033fbd58a461102a" id="r_ab81c48c60fc42fdd033fbd58a461102a"><td class="memItemLeft" align="right" valign="top">typedef struct mpv_byte_array&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab81c48c60fc42fdd033fbd58a461102a">mpv_byte_array</a></td></tr>
<tr class="separator:ab81c48c60fc42fdd033fbd58a461102a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135d0130e68283ee6f934d18dcfba646" id="r_a135d0130e68283ee6f934d18dcfba646"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="#aab05e07858ef82e9c08f7e3727f5d40c">mpv_event_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a135d0130e68283ee6f934d18dcfba646">mpv_event_id</a></td></tr>
<tr class="separator:a135d0130e68283ee6f934d18dcfba646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad536827cd31aefcccd1e2339adbfed3d" id="r_ad536827cd31aefcccd1e2339adbfed3d"><td class="memItemLeft" align="right" valign="top">typedef struct mpv_event_property&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad536827cd31aefcccd1e2339adbfed3d">mpv_event_property</a></td></tr>
<tr class="separator:ad536827cd31aefcccd1e2339adbfed3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df1b3a994878c6c26428f0b6d164c51" id="r_a0df1b3a994878c6c26428f0b6d164c51"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="#a53ff39f9b884d7bc6dd30bd612365ae9">mpv_log_level</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0df1b3a994878c6c26428f0b6d164c51">mpv_log_level</a></td></tr>
<tr class="separator:a0df1b3a994878c6c26428f0b6d164c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1308c0ba51f270d39aae244705d8132" id="r_af1308c0ba51f270d39aae244705d8132"><td class="memItemLeft" align="right" valign="top">typedef struct mpv_event_log_message&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1308c0ba51f270d39aae244705d8132">mpv_event_log_message</a></td></tr>
<tr class="separator:af1308c0ba51f270d39aae244705d8132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82ccaf3c5f76032eeca204fea40bbfb0" id="r_a82ccaf3c5f76032eeca204fea40bbfb0"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="#a888a4fa4a307ad54ec74e5f4a5862f1d">mpv_end_file_reason</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82ccaf3c5f76032eeca204fea40bbfb0">mpv_end_file_reason</a></td></tr>
<tr class="memdesc:a82ccaf3c5f76032eeca204fea40bbfb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Since API version 1.9.  <br /></td></tr>
<tr class="separator:a82ccaf3c5f76032eeca204fea40bbfb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d52be4b3d145102c88501d83a6ec61" id="r_a37d52be4b3d145102c88501d83a6ec61"><td class="memItemLeft" align="right" valign="top">typedef struct mpv_event_start_file&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37d52be4b3d145102c88501d83a6ec61">mpv_event_start_file</a></td></tr>
<tr class="memdesc:a37d52be4b3d145102c88501d83a6ec61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Since API version 1.108.  <br /></td></tr>
<tr class="separator:a37d52be4b3d145102c88501d83a6ec61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e162478350b4b363ca6c7ebdfd4799a" id="r_a4e162478350b4b363ca6c7ebdfd4799a"><td class="memItemLeft" align="right" valign="top">typedef struct mpv_event_end_file&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e162478350b4b363ca6c7ebdfd4799a">mpv_event_end_file</a></td></tr>
<tr class="separator:a4e162478350b4b363ca6c7ebdfd4799a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a992a187ef3668df17d913f9297aaef0a" id="r_a992a187ef3668df17d913f9297aaef0a"><td class="memItemLeft" align="right" valign="top">typedef struct mpv_event_client_message&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a992a187ef3668df17d913f9297aaef0a">mpv_event_client_message</a></td></tr>
<tr class="separator:a992a187ef3668df17d913f9297aaef0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af58e67c1c4e759e47b45aa986126500a" id="r_af58e67c1c4e759e47b45aa986126500a"><td class="memItemLeft" align="right" valign="top">typedef struct mpv_event_hook&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af58e67c1c4e759e47b45aa986126500a">mpv_event_hook</a></td></tr>
<tr class="separator:af58e67c1c4e759e47b45aa986126500a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cddceaeb1a3e52f0ee7816b01354802" id="r_a4cddceaeb1a3e52f0ee7816b01354802"><td class="memItemLeft" align="right" valign="top">typedef struct mpv_event_command&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4cddceaeb1a3e52f0ee7816b01354802">mpv_event_command</a></td></tr>
<tr class="separator:a4cddceaeb1a3e52f0ee7816b01354802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e83267caf73a2a25e7302569537fc1" id="r_a08e83267caf73a2a25e7302569537fc1"><td class="memItemLeft" align="right" valign="top">typedef struct mpv_event&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08e83267caf73a2a25e7302569537fc1">mpv_event</a></td></tr>
<tr class="separator:a08e83267caf73a2a25e7302569537fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
枚举</h2></td></tr>
<tr class="memitem:ae3ecabf6277821768141a86e5fad779f" id="r_ae3ecabf6277821768141a86e5fad779f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3ecabf6277821768141a86e5fad779f">mpv_error</a> { <br />
&#160;&#160;<a class="el" href="#ae3ecabf6277821768141a86e5fad779fae4b8c4f440e1c6e3e1e35b15850902d7">MPV_ERROR_SUCCESS</a> = 0
, <a class="el" href="#ae3ecabf6277821768141a86e5fad779fa7eeb3ee291759d6a7edacf5be26bf7dc">MPV_ERROR_EVENT_QUEUE_FULL</a> = -1
, <a class="el" href="#ae3ecabf6277821768141a86e5fad779fac1ec769fb8e8e32db4be14cb378a9cc5">MPV_ERROR_NOMEM</a> = -2
, <a class="el" href="#ae3ecabf6277821768141a86e5fad779fa6bddd4b8e3060f3e1e2f25e89e8828fe">MPV_ERROR_UNINITIALIZED</a> = -3
, <br />
&#160;&#160;<a class="el" href="#ae3ecabf6277821768141a86e5fad779fa6759d447b337febf1348151b3e31cc7b">MPV_ERROR_INVALID_PARAMETER</a> = -4
, <a class="el" href="#ae3ecabf6277821768141a86e5fad779faa0b5d95c5ba90a734b25afff64001d2e">MPV_ERROR_OPTION_NOT_FOUND</a> = -5
, <a class="el" href="#ae3ecabf6277821768141a86e5fad779fae0d43d853df62b97334a74d431839e9e">MPV_ERROR_OPTION_FORMAT</a> = -6
, <a class="el" href="#ae3ecabf6277821768141a86e5fad779fae44979d46f05dbd66878df705977980d">MPV_ERROR_OPTION_ERROR</a> = -7
, <br />
&#160;&#160;<a class="el" href="#ae3ecabf6277821768141a86e5fad779fad1e39800ef57dcc7f2cc86cd82f99220">MPV_ERROR_PROPERTY_NOT_FOUND</a> = -8
, <a class="el" href="#ae3ecabf6277821768141a86e5fad779fa585e54b40613281530f2e74821b6ff27">MPV_ERROR_PROPERTY_FORMAT</a> = -9
, <a class="el" href="#ae3ecabf6277821768141a86e5fad779fa72a320b2fd86de980fb7ad35cd70fc1d">MPV_ERROR_PROPERTY_UNAVAILABLE</a> = -10
, <a class="el" href="#ae3ecabf6277821768141a86e5fad779fa3cb278a68a3b842d01cfd379fd9af145">MPV_ERROR_PROPERTY_ERROR</a> = -11
, <br />
&#160;&#160;<a class="el" href="#ae3ecabf6277821768141a86e5fad779fa498aeb7d75d4e6e6fb705fa20352c523">MPV_ERROR_COMMAND</a> = -12
, <a class="el" href="#ae3ecabf6277821768141a86e5fad779fa356d084931199d04f5b127ae16f6ed76">MPV_ERROR_LOADING_FAILED</a> = -13
, <a class="el" href="#ae3ecabf6277821768141a86e5fad779fab33d5950518338439ada112af53d9801">MPV_ERROR_AO_INIT_FAILED</a> = -14
, <a class="el" href="#ae3ecabf6277821768141a86e5fad779fa69ca882ff793b2bb7d32e32b58471d0b">MPV_ERROR_VO_INIT_FAILED</a> = -15
, <br />
&#160;&#160;<a class="el" href="#ae3ecabf6277821768141a86e5fad779fab2e56f0ceef984b32cb5c85fc39d7e34">MPV_ERROR_NOTHING_TO_PLAY</a> = -16
, <a class="el" href="#ae3ecabf6277821768141a86e5fad779fa47210404529fb770cce5760de18f1a22">MPV_ERROR_UNKNOWN_FORMAT</a> = -17
, <a class="el" href="#ae3ecabf6277821768141a86e5fad779fa0c4873c88cf49bb05ffbd1ce7e81d99b">MPV_ERROR_UNSUPPORTED</a> = -18
, <a class="el" href="#ae3ecabf6277821768141a86e5fad779fa189f2f9013fb236a39ba49beb36acd1f">MPV_ERROR_NOT_IMPLEMENTED</a> = -19
, <br />
&#160;&#160;<a class="el" href="#ae3ecabf6277821768141a86e5fad779fa455ae6916f3f9c863f1611e12575f0d9">MPV_ERROR_GENERIC</a> = -20
<br />
 }</td></tr>
<tr class="separator:ae3ecabf6277821768141a86e5fad779f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de0a5cfaeed2adfe0c344df68ba292f" id="r_a8de0a5cfaeed2adfe0c344df68ba292f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8de0a5cfaeed2adfe0c344df68ba292f">mpv_format</a> { <br />
&#160;&#160;<a class="el" href="#a8de0a5cfaeed2adfe0c344df68ba292fa6a7adaa924f7ca11428d43fd9e3dfddd">MPV_FORMAT_NONE</a> = 0
, <a class="el" href="#a8de0a5cfaeed2adfe0c344df68ba292fa5cc32ffe7bcb782694d9166d8706b02b">MPV_FORMAT_STRING</a> = 1
, <a class="el" href="#a8de0a5cfaeed2adfe0c344df68ba292fade7699590e8fea898fc1252b011d6886">MPV_FORMAT_OSD_STRING</a> = 2
, <a class="el" href="#a8de0a5cfaeed2adfe0c344df68ba292fa8b91160f26b4055bc7d11d51ad5b330a">MPV_FORMAT_FLAG</a> = 3
, <br />
&#160;&#160;<a class="el" href="#a8de0a5cfaeed2adfe0c344df68ba292fa72f5f173309907653b822a3667cee129">MPV_FORMAT_INT64</a> = 4
, <a class="el" href="#a8de0a5cfaeed2adfe0c344df68ba292faea4c9937759ab544e0a172261efa6d91">MPV_FORMAT_DOUBLE</a> = 5
, <a class="el" href="#a8de0a5cfaeed2adfe0c344df68ba292fab46e83affdfce6887cd381c2642faeb0">MPV_FORMAT_NODE</a> = 6
, <a class="el" href="#a8de0a5cfaeed2adfe0c344df68ba292faf42f8145b18decb18e792f8fbb45dc90">MPV_FORMAT_NODE_ARRAY</a> = 7
, <br />
&#160;&#160;<a class="el" href="#a8de0a5cfaeed2adfe0c344df68ba292fa60621f73f6bf466bac85deca57aa733c">MPV_FORMAT_NODE_MAP</a> = 8
, <a class="el" href="#a8de0a5cfaeed2adfe0c344df68ba292fa6662cf5d2f89511643d51531d3714e6f">MPV_FORMAT_BYTE_ARRAY</a> = 9
<br />
 }</td></tr>
<tr class="separator:a8de0a5cfaeed2adfe0c344df68ba292f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab05e07858ef82e9c08f7e3727f5d40c" id="r_aab05e07858ef82e9c08f7e3727f5d40c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab05e07858ef82e9c08f7e3727f5d40c">mpv_event_id</a> { <br />
&#160;&#160;<a class="el" href="#aab05e07858ef82e9c08f7e3727f5d40ca8fcfbc9e8dd1e3d06c2ebda6abaa7a0f">MPV_EVENT_NONE</a> = 0
, <a class="el" href="#aab05e07858ef82e9c08f7e3727f5d40ca528dd526c9db22231c27181d97e66e5b">MPV_EVENT_SHUTDOWN</a> = 1
, <a class="el" href="#aab05e07858ef82e9c08f7e3727f5d40caba2305825e4f242faebd9b1b53c0923f">MPV_EVENT_LOG_MESSAGE</a> = 2
, <a class="el" href="#aab05e07858ef82e9c08f7e3727f5d40ca425bb5605d4009120e95a51f6417e086">MPV_EVENT_GET_PROPERTY_REPLY</a> = 3
, <br />
&#160;&#160;<a class="el" href="#aab05e07858ef82e9c08f7e3727f5d40cadbcd7440b0551b94a46e459be407c10d">MPV_EVENT_SET_PROPERTY_REPLY</a> = 4
, <a class="el" href="#aab05e07858ef82e9c08f7e3727f5d40ca8956f1fff5127c3766f31c349331e3fe">MPV_EVENT_COMMAND_REPLY</a> = 5
, <a class="el" href="#aab05e07858ef82e9c08f7e3727f5d40ca929c29b70b43b54bc2f365496da3f292">MPV_EVENT_START_FILE</a> = 6
, <a class="el" href="#aab05e07858ef82e9c08f7e3727f5d40ca07d453b2bf4aad8682b5333fe8ccefd6">MPV_EVENT_END_FILE</a> = 7
, <br />
&#160;&#160;<a class="el" href="#aab05e07858ef82e9c08f7e3727f5d40ca70282f17d5fd70607d43ae39149da16e">MPV_EVENT_FILE_LOADED</a> = 8
, <a class="el" href="#aab05e07858ef82e9c08f7e3727f5d40cacca46466ad6358939a65946b90bd4576">MPV_EVENT_IDLE</a> = 11
, <a class="el" href="#aab05e07858ef82e9c08f7e3727f5d40ca6717605195a003a3a832df83cb4f622f">MPV_EVENT_TICK</a> = 14
, <a class="el" href="#aab05e07858ef82e9c08f7e3727f5d40ca65cffe5cbfad29019d3c8661ffa44e68">MPV_EVENT_CLIENT_MESSAGE</a> = 16
, <br />
&#160;&#160;<a class="el" href="#aab05e07858ef82e9c08f7e3727f5d40ca5a15cd0e9004fe93dc63b3577a09963d">MPV_EVENT_VIDEO_RECONFIG</a> = 17
, <a class="el" href="#aab05e07858ef82e9c08f7e3727f5d40cada5daf7400912e10335adc938be117b4">MPV_EVENT_AUDIO_RECONFIG</a> = 18
, <a class="el" href="#aab05e07858ef82e9c08f7e3727f5d40ca71d61460b78ec87065abc5f8534fec53">MPV_EVENT_SEEK</a> = 20
, <a class="el" href="#aab05e07858ef82e9c08f7e3727f5d40cadd91d1ffd840031176fe18004971f93e">MPV_EVENT_PLAYBACK_RESTART</a> = 21
, <br />
&#160;&#160;<a class="el" href="#aab05e07858ef82e9c08f7e3727f5d40ca22001e3203cb76ab62c63da90d1e9128">MPV_EVENT_PROPERTY_CHANGE</a> = 22
, <a class="el" href="#aab05e07858ef82e9c08f7e3727f5d40ca0049354fca7804792174194b44e238cc">MPV_EVENT_QUEUE_OVERFLOW</a> = 24
, <a class="el" href="#aab05e07858ef82e9c08f7e3727f5d40cae6dbcd25c3b4b4d6c2ab551e6f02eede">MPV_EVENT_HOOK</a> = 25
<br />
 }</td></tr>
<tr class="separator:aab05e07858ef82e9c08f7e3727f5d40c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ff39f9b884d7bc6dd30bd612365ae9" id="r_a53ff39f9b884d7bc6dd30bd612365ae9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53ff39f9b884d7bc6dd30bd612365ae9">mpv_log_level</a> { <br />
&#160;&#160;<a class="el" href="#a53ff39f9b884d7bc6dd30bd612365ae9a9fe29725ff35b9c9d9349f07dcf6a355">MPV_LOG_LEVEL_NONE</a> = 0
, <a class="el" href="#a53ff39f9b884d7bc6dd30bd612365ae9acbf42c9592b7fd2c809d0f6471311037">MPV_LOG_LEVEL_FATAL</a> = 10
, <a class="el" href="#a53ff39f9b884d7bc6dd30bd612365ae9a9f50162077d5f3a05872399782204ff4">MPV_LOG_LEVEL_ERROR</a> = 20
, <a class="el" href="#a53ff39f9b884d7bc6dd30bd612365ae9a96b343079df13e95b8e13e094b556d01">MPV_LOG_LEVEL_WARN</a> = 30
, <br />
&#160;&#160;<a class="el" href="#a53ff39f9b884d7bc6dd30bd612365ae9ac131682b89bf88e09f26d59490cb8645">MPV_LOG_LEVEL_INFO</a> = 40
, <a class="el" href="#a53ff39f9b884d7bc6dd30bd612365ae9abe26075b2da0242469bc554b67f9bf4d">MPV_LOG_LEVEL_V</a> = 50
, <a class="el" href="#a53ff39f9b884d7bc6dd30bd612365ae9aa11c4d0c660c1f02de5b3110e2d8901e">MPV_LOG_LEVEL_DEBUG</a> = 60
, <a class="el" href="#a53ff39f9b884d7bc6dd30bd612365ae9a2119f36591c715b0710852c77b6f13dd">MPV_LOG_LEVEL_TRACE</a> = 70
<br />
 }</td></tr>
<tr class="separator:a53ff39f9b884d7bc6dd30bd612365ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888a4fa4a307ad54ec74e5f4a5862f1d" id="r_a888a4fa4a307ad54ec74e5f4a5862f1d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a888a4fa4a307ad54ec74e5f4a5862f1d">mpv_end_file_reason</a> { <br />
&#160;&#160;<a class="el" href="#a888a4fa4a307ad54ec74e5f4a5862f1da10573a7dc2c64799d2bce2bed3b6071c">MPV_END_FILE_REASON_EOF</a> = 0
, <a class="el" href="#a888a4fa4a307ad54ec74e5f4a5862f1da58885a49994cc7ace30e78b1d279963b">MPV_END_FILE_REASON_STOP</a> = 2
, <a class="el" href="#a888a4fa4a307ad54ec74e5f4a5862f1da0248e0f6cde8b8bf64a612721086481d">MPV_END_FILE_REASON_QUIT</a> = 3
, <a class="el" href="#a888a4fa4a307ad54ec74e5f4a5862f1da1c6617645e83398ca8876254d276be06">MPV_END_FILE_REASON_ERROR</a> = 4
, <br />
&#160;&#160;<a class="el" href="#a888a4fa4a307ad54ec74e5f4a5862f1da99bc85aa86b2fc54e6bf7fa4c81733d4">MPV_END_FILE_REASON_REDIRECT</a> = 5
<br />
 }</td></tr>
<tr class="memdesc:a888a4fa4a307ad54ec74e5f4a5862f1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Since API version 1.9.  <a href="#a888a4fa4a307ad54ec74e5f4a5862f1d">更多...</a><br /></td></tr>
<tr class="separator:a888a4fa4a307ad54ec74e5f4a5862f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
函数</h2></td></tr>
<tr class="memitem:a175393956041e67ae34f45b808d4409c" id="r_a175393956041e67ae34f45b808d4409c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a175393956041e67ae34f45b808d4409c">mpv_client_api_version</a> (void)</td></tr>
<tr class="separator:a175393956041e67ae34f45b808d4409c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c1f3705e6918d81286fb55ac6c5294" id="r_a71c1f3705e6918d81286fb55ac6c5294"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71c1f3705e6918d81286fb55ac6c5294">mpv_error_string</a> (int error)</td></tr>
<tr class="separator:a71c1f3705e6918d81286fb55ac6c5294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585d349a4005c7eaf01f28f59eb9e4ea" id="r_a585d349a4005c7eaf01f28f59eb9e4ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a585d349a4005c7eaf01f28f59eb9e4ea">mpv_free</a> (void *data)</td></tr>
<tr class="separator:a585d349a4005c7eaf01f28f59eb9e4ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed74ba4e80320ee0a9b16cba220ff4d" id="r_a6ed74ba4e80320ee0a9b16cba220ff4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ed74ba4e80320ee0a9b16cba220ff4d">mpv_client_name</a> (<a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *ctx)</td></tr>
<tr class="separator:a6ed74ba4e80320ee0a9b16cba220ff4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f88479040dfe2d2a84e4024c0dce73" id="r_a37f88479040dfe2d2a84e4024c0dce73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37f88479040dfe2d2a84e4024c0dce73">mpv_client_id</a> (<a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *ctx)</td></tr>
<tr class="separator:a37f88479040dfe2d2a84e4024c0dce73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acabb8d28abfb2614024eaa58a4de36e8" id="r_acabb8d28abfb2614024eaa58a4de36e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> <a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acabb8d28abfb2614024eaa58a4de36e8">mpv_create</a> (void)</td></tr>
<tr class="separator:acabb8d28abfb2614024eaa58a4de36e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760868c77375524a884ca11917e9fe8b" id="r_a760868c77375524a884ca11917e9fe8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a760868c77375524a884ca11917e9fe8b">mpv_initialize</a> (<a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *ctx)</td></tr>
<tr class="separator:a760868c77375524a884ca11917e9fe8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12b97104f3bbe302d96260c33728f07" id="r_ae12b97104f3bbe302d96260c33728f07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae12b97104f3bbe302d96260c33728f07">mpv_destroy</a> (<a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *ctx)</td></tr>
<tr class="separator:ae12b97104f3bbe302d96260c33728f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831ff5d62abb8eab842af9ec23f182a6" id="r_a831ff5d62abb8eab842af9ec23f182a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a831ff5d62abb8eab842af9ec23f182a6">mpv_terminate_destroy</a> (<a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *ctx)</td></tr>
<tr class="separator:a831ff5d62abb8eab842af9ec23f182a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645dba46c9ab76eefe2cd9d3343dbf49" id="r_a645dba46c9ab76eefe2cd9d3343dbf49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> <a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a645dba46c9ab76eefe2cd9d3343dbf49">mpv_create_client</a> (<a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *ctx, const char *name)</td></tr>
<tr class="separator:a645dba46c9ab76eefe2cd9d3343dbf49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c555fbf54ab016966b4b6213241fe7" id="r_af6c555fbf54ab016966b4b6213241fe7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> <a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6c555fbf54ab016966b4b6213241fe7">mpv_create_weak_client</a> (<a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *ctx, const char *name)</td></tr>
<tr class="separator:af6c555fbf54ab016966b4b6213241fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a934a427f05ac9e93b78168ea0eee5c24" id="r_a934a427f05ac9e93b78168ea0eee5c24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a934a427f05ac9e93b78168ea0eee5c24">mpv_load_config_file</a> (<a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *ctx, const char *filename)</td></tr>
<tr class="separator:a934a427f05ac9e93b78168ea0eee5c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4cf360b8f86e7fdbabced592b93411" id="r_adf4cf360b8f86e7fdbabced592b93411"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf4cf360b8f86e7fdbabced592b93411">mpv_get_time_ns</a> (<a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *ctx)</td></tr>
<tr class="separator:adf4cf360b8f86e7fdbabced592b93411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a855c8887b117fa6fed3e89b3c1d98c90" id="r_a855c8887b117fa6fed3e89b3c1d98c90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a855c8887b117fa6fed3e89b3c1d98c90">mpv_get_time_us</a> (<a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *ctx)</td></tr>
<tr class="separator:a855c8887b117fa6fed3e89b3c1d98c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc4983d9482000f58cd14ee66cdf8ba" id="r_a4dc4983d9482000f58cd14ee66cdf8ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4dc4983d9482000f58cd14ee66cdf8ba">mpv_free_node_contents</a> (<a class="el" href="structmpv__node.html">mpv_node</a> *node)</td></tr>
<tr class="separator:a4dc4983d9482000f58cd14ee66cdf8ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb89863e899876b11de5bf7c6b78912" id="r_a2eb89863e899876b11de5bf7c6b78912"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2eb89863e899876b11de5bf7c6b78912">mpv_set_option</a> (<a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *ctx, const char *name, <a class="el" href="#a8de0a5cfaeed2adfe0c344df68ba292f">mpv_format</a> format, void *data)</td></tr>
<tr class="separator:a2eb89863e899876b11de5bf7c6b78912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada06ff1f821683e60b531d96ccc69264" id="r_ada06ff1f821683e60b531d96ccc69264"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada06ff1f821683e60b531d96ccc69264">mpv_set_option_string</a> (<a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *ctx, const char *name, const char *data)</td></tr>
<tr class="separator:ada06ff1f821683e60b531d96ccc69264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44c1102744f5fa60fec80747fc9b856" id="r_aa44c1102744f5fa60fec80747fc9b856"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa44c1102744f5fa60fec80747fc9b856">mpv_command</a> (<a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *ctx, const char **args)</td></tr>
<tr class="separator:aa44c1102744f5fa60fec80747fc9b856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf02e02b212a8b588ba8723643e8ebe9" id="r_abf02e02b212a8b588ba8723643e8ebe9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf02e02b212a8b588ba8723643e8ebe9">mpv_command_node</a> (<a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *ctx, <a class="el" href="structmpv__node.html">mpv_node</a> *args, <a class="el" href="structmpv__node.html">mpv_node</a> *result)</td></tr>
<tr class="separator:abf02e02b212a8b588ba8723643e8ebe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a823905244ca283d829e9e4e1c504347f" id="r_a823905244ca283d829e9e4e1c504347f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a823905244ca283d829e9e4e1c504347f">mpv_command_ret</a> (<a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *ctx, const char **args, <a class="el" href="structmpv__node.html">mpv_node</a> *result)</td></tr>
<tr class="separator:a823905244ca283d829e9e4e1c504347f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb8e995b0d83679a630ba4100a3b9ba9" id="r_aeb8e995b0d83679a630ba4100a3b9ba9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb8e995b0d83679a630ba4100a3b9ba9">mpv_command_string</a> (<a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *ctx, const char *args)</td></tr>
<tr class="separator:aeb8e995b0d83679a630ba4100a3b9ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0eb9659d717174434d6c69bb0be089b" id="r_aa0eb9659d717174434d6c69bb0be089b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0eb9659d717174434d6c69bb0be089b">mpv_command_async</a> (<a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *ctx, uint64_t reply_userdata, const char **args)</td></tr>
<tr class="separator:aa0eb9659d717174434d6c69bb0be089b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b980e553adb8231b396555c6c8c8490" id="r_a3b980e553adb8231b396555c6c8c8490"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b980e553adb8231b396555c6c8c8490">mpv_command_node_async</a> (<a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *ctx, uint64_t reply_userdata, <a class="el" href="structmpv__node.html">mpv_node</a> *args)</td></tr>
<tr class="separator:a3b980e553adb8231b396555c6c8c8490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad77571834b9234894246b294d1c72d8" id="r_aad77571834b9234894246b294d1c72d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad77571834b9234894246b294d1c72d8">mpv_abort_async_command</a> (<a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *ctx, uint64_t reply_userdata)</td></tr>
<tr class="separator:aad77571834b9234894246b294d1c72d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b9322b70a70cc09f8204d689df97a3" id="r_a95b9322b70a70cc09f8204d689df97a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95b9322b70a70cc09f8204d689df97a3">mpv_set_property</a> (<a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *ctx, const char *name, <a class="el" href="#a8de0a5cfaeed2adfe0c344df68ba292f">mpv_format</a> format, void *data)</td></tr>
<tr class="separator:a95b9322b70a70cc09f8204d689df97a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a292257755e6b358b045254ef1e4534d8" id="r_a292257755e6b358b045254ef1e4534d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a292257755e6b358b045254ef1e4534d8">mpv_set_property_string</a> (<a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *ctx, const char *name, const char *data)</td></tr>
<tr class="separator:a292257755e6b358b045254ef1e4534d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63578b469f1aa1e4dcf7d0cb201735cc" id="r_a63578b469f1aa1e4dcf7d0cb201735cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63578b469f1aa1e4dcf7d0cb201735cc">mpv_del_property</a> (<a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *ctx, const char *name)</td></tr>
<tr class="separator:a63578b469f1aa1e4dcf7d0cb201735cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3df8b17cb495fb877af6957520df0ed" id="r_af3df8b17cb495fb877af6957520df0ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3df8b17cb495fb877af6957520df0ed">mpv_set_property_async</a> (<a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *ctx, uint64_t reply_userdata, const char *name, <a class="el" href="#a8de0a5cfaeed2adfe0c344df68ba292f">mpv_format</a> format, void *data)</td></tr>
<tr class="separator:af3df8b17cb495fb877af6957520df0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca58b3b9eadb3cd70953d9cba238958" id="r_aeca58b3b9eadb3cd70953d9cba238958"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeca58b3b9eadb3cd70953d9cba238958">mpv_get_property</a> (<a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *ctx, const char *name, <a class="el" href="#a8de0a5cfaeed2adfe0c344df68ba292f">mpv_format</a> format, void *data)</td></tr>
<tr class="separator:aeca58b3b9eadb3cd70953d9cba238958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f459695d01260a86ca746e1b50e39a" id="r_a83f459695d01260a86ca746e1b50e39a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83f459695d01260a86ca746e1b50e39a">mpv_get_property_string</a> (<a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *ctx, const char *name, <a class="el" href="#a8de0a5cfaeed2adfe0c344df68ba292f">mpv_format</a> format, char **pString)</td></tr>
<tr class="separator:a83f459695d01260a86ca746e1b50e39a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f5a5bf7777b723a3ffec94f6264525" id="r_a87f5a5bf7777b723a3ffec94f6264525"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87f5a5bf7777b723a3ffec94f6264525">mpv_get_property_osd_string</a> (<a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *ctx, const char *name)</td></tr>
<tr class="separator:a87f5a5bf7777b723a3ffec94f6264525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d2ef781815c9eea2614d5267c7cf6e" id="r_a08d2ef781815c9eea2614d5267c7cf6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08d2ef781815c9eea2614d5267c7cf6e">mpv_get_property_async</a> (<a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *ctx, uint64_t reply_userdata, const char *name, <a class="el" href="#a8de0a5cfaeed2adfe0c344df68ba292f">mpv_format</a> format)</td></tr>
<tr class="separator:a08d2ef781815c9eea2614d5267c7cf6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d2b287c0f994fb3649c1a1bf85591e" id="r_af3d2b287c0f994fb3649c1a1bf85591e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3d2b287c0f994fb3649c1a1bf85591e">mpv_observe_property</a> (<a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *mpv, uint64_t reply_userdata, const char *name, <a class="el" href="#a8de0a5cfaeed2adfe0c344df68ba292f">mpv_format</a> format)</td></tr>
<tr class="separator:af3d2b287c0f994fb3649c1a1bf85591e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc02c1e7054f92c7e7502d88336d57e" id="r_a8cc02c1e7054f92c7e7502d88336d57e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8cc02c1e7054f92c7e7502d88336d57e">mpv_unobserve_property</a> (<a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *mpv, uint64_t registered_reply_userdata)</td></tr>
<tr class="separator:a8cc02c1e7054f92c7e7502d88336d57e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca6494a0cc3799cf13f97ed9927073f" id="r_a8ca6494a0cc3799cf13f97ed9927073f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ca6494a0cc3799cf13f97ed9927073f">mpv_event_name</a> (<a class="el" href="#aab05e07858ef82e9c08f7e3727f5d40c">mpv_event_id</a> event)</td></tr>
<tr class="separator:a8ca6494a0cc3799cf13f97ed9927073f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a4b06230913cabddf6bfbfe701f110" id="r_a59a4b06230913cabddf6bfbfe701f110"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59a4b06230913cabddf6bfbfe701f110">mpv_event_to_node</a> (<a class="el" href="structmpv__node.html">mpv_node</a> *dst, <a class="el" href="structmpv__event.html">mpv_event</a> *src)</td></tr>
<tr class="separator:a59a4b06230913cabddf6bfbfe701f110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c37df225044f5f8db5cb0c048fa902" id="r_a71c37df225044f5f8db5cb0c048fa902"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71c37df225044f5f8db5cb0c048fa902">mpv_request_event</a> (<a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *ctx, <a class="el" href="#aab05e07858ef82e9c08f7e3727f5d40c">mpv_event_id</a> event, int enable)</td></tr>
<tr class="separator:a71c37df225044f5f8db5cb0c048fa902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cd1f2768f461a351a1d8ad345539492" id="r_a2cd1f2768f461a351a1d8ad345539492"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2cd1f2768f461a351a1d8ad345539492">mpv_request_log_messages</a> (<a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *ctx, const char *min_level)</td></tr>
<tr class="separator:a2cd1f2768f461a351a1d8ad345539492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14715be5aab817bb71770f711b64102a" id="r_a14715be5aab817bb71770f711b64102a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> <a class="el" href="structmpv__event.html">mpv_event</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14715be5aab817bb71770f711b64102a">mpv_wait_event</a> (<a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *ctx, double timeout)</td></tr>
<tr class="separator:a14715be5aab817bb71770f711b64102a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365ef47a0f79325577c714799bb4899e" id="r_a365ef47a0f79325577c714799bb4899e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a365ef47a0f79325577c714799bb4899e">mpv_wakeup</a> (<a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *ctx)</td></tr>
<tr class="separator:a365ef47a0f79325577c714799bb4899e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b24fa9076b9c0ca5f988709d20e736" id="r_a54b24fa9076b9c0ca5f988709d20e736"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54b24fa9076b9c0ca5f988709d20e736">mpv_set_wakeup_callback</a> (<a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *ctx, void(*cb)(void *d), void *d)</td></tr>
<tr class="separator:a54b24fa9076b9c0ca5f988709d20e736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df66904a005a9c15b6cb9f4e7caa223" id="r_a4df66904a005a9c15b6cb9f4e7caa223"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4df66904a005a9c15b6cb9f4e7caa223">mpv_wait_async_requests</a> (<a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *ctx)</td></tr>
<tr class="separator:a4df66904a005a9c15b6cb9f4e7caa223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96a59b780ea3a0d7cf01c71116e136f" id="r_af96a59b780ea3a0d7cf01c71116e136f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af96a59b780ea3a0d7cf01c71116e136f">mpv_hook_add</a> (<a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *ctx, uint64_t reply_userdata, const char *name, int priority)</td></tr>
<tr class="separator:af96a59b780ea3a0d7cf01c71116e136f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd7bc86098f32e660bda2c14ca2eda6" id="r_a6dd7bc86098f32e660bda2c14ca2eda6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6dd7bc86098f32e660bda2c14ca2eda6">mpv_hook_continue</a> (<a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *ctx, uint64_t id)</td></tr>
<tr class="separator:a6dd7bc86098f32e660bda2c14ca2eda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb5fcef1a43e3d3462fa138cff39339" id="r_aaeb5fcef1a43e3d3462fa138cff39339"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaeb5fcef1a43e3d3462fa138cff39339">mpv_get_wakeup_pipe</a> (<a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *ctx)</td></tr>
<tr class="separator:aaeb5fcef1a43e3d3462fa138cff39339"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">宏定义说明</h2>
<a id="a91cbe68751252981e05719088d7cb3b0" name="a91cbe68751252981e05719088d7cb3b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91cbe68751252981e05719088d7cb3b0">&#9670;&#160;</a></span>MPV_CLIENT_API_VERSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MPV_CLIENT_API_VERSION&#160;&#160;&#160;<a class="el" href="#a8f9935d5ba969afe3bd22bb67e2759a1">MPV_MAKE_VERSION</a>(2, 2)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">在文件 <a class="el" href="client_8h_source.html">client.h</a> 第 <a class="el" href="client_8h_source.html#l00251">251</a> 行定义.</p>

</div>
</div>
<a id="ae292682d85e3c5efe48447ee8fa04f2c" name="ae292682d85e3c5efe48447ee8fa04f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae292682d85e3c5efe48447ee8fa04f2c">&#9670;&#160;</a></span>MPV_DECLTYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MPV_DECLTYPE&#160;&#160;&#160;__typeof__</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">在文件 <a class="el" href="client_8h_source.html">client.h</a> 第 <a class="el" href="client_8h_source.html#l00043">43</a> 行定义.</p>

</div>
</div>
<a id="a668c00e17d4fe9298a8a72cd535a74a7" name="a668c00e17d4fe9298a8a72cd535a74a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a668c00e17d4fe9298a8a72cd535a74a7">&#9670;&#160;</a></span>MPV_ENABLE_DEPRECATED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MPV_ENABLE_DEPRECATED&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The API user is allowed to "#define MPV_ENABLE_DEPRECATED 0" before including any mpv headers. Then deprecated symbols will be excluded from the headers. (Of course, deprecated properties and commands and other functionality will still work.) </p>

<p class="definition">在文件 <a class="el" href="client_8h_source.html">client.h</a> 第 <a class="el" href="client_8h_source.html#l00260">260</a> 行定义.</p>

</div>
</div>
<a id="a645bac051595e752c4527981767d1604" name="a645bac051595e752c4527981767d1604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a645bac051595e752c4527981767d1604">&#9670;&#160;</a></span>MPV_EXPORT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MPV_EXPORT</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">在文件 <a class="el" href="client_8h_source.html">client.h</a> 第 <a class="el" href="client_8h_source.html#l00036">36</a> 行定义.</p>

</div>
</div>
<a id="a8f9935d5ba969afe3bd22bb67e2759a1" name="a8f9935d5ba969afe3bd22bb67e2759a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f9935d5ba969afe3bd22bb67e2759a1">&#9670;&#160;</a></span>MPV_MAKE_VERSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MPV_MAKE_VERSION</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">major, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname">minor</span>&#160;)&#160;&#160;&#160;(((major) &lt;&lt; 16) | (minor) | 0UL)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h2><a class="anchor" id="autotoc_md0"></a>
Mechanisms provided by this API</h2>
<p>This API provides general control over mpv playback. It does not give you direct access to individual components of the player, only the whole thing. It's somewhat equivalent to MPlayer's slave mode. You can send commands, retrieve or set playback status or settings with properties, and receive events.</p>
<p>The API can be used in two ways: 1) Internally in mpv, to provide additional features to the command line player. Lua scripting uses this. (Currently there is no plugin API to get a client API handle in external user code. It has to be a fixed part of the player at compilation time.) 2) Using mpv as a library with <a class="el" href="#acabb8d28abfb2614024eaa58a4de36e8">mpv_create()</a>. This basically allows embedding mpv in other applications.</p>
<h2><a class="anchor" id="autotoc_md1"></a>
Documentation</h2>
<p>The mpv C API is documented directly in this header. Note that most actual interaction with this player is done through options/commands/properties, which can be accessed through this API. Essentially everything is done with them, including loading a file, retrieving playback progress, and so on.</p>
<p>These are documented elsewhere:</p><ul>
<li><a href="http://mpv.io/manual/master/#options">http://mpv.io/manual/master/#options</a></li>
<li><a href="http://mpv.io/manual/master/#list-of-input-commands">http://mpv.io/manual/master/#list-of-input-commands</a></li>
<li><a href="http://mpv.io/manual/master/#properties">http://mpv.io/manual/master/#properties</a></li>
</ul>
<p>You can also look at the examples here:</p><ul>
<li><a href="https://github.com/mpv-player/mpv-examples/tree/master/mpv">https://github.com/mpv-player/mpv-examples/tree/master/mpv</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md2"></a>
Event loop</h2>
<p>In general, the API user should run an event loop in order to receive events. This event loop should call <a class="el" href="#a14715be5aab817bb71770f711b64102a">mpv_wait_event()</a>, which will return once a new mpv client API is available. It is also possible to integrate client API usage in other event loops (e.g. GUI toolkits) with the <a class="el" href="#a54b24fa9076b9c0ca5f988709d20e736">mpv_set_wakeup_callback()</a> function, and then polling for events by calling <a class="el" href="#a14715be5aab817bb71770f711b64102a">mpv_wait_event()</a> with a 0 timeout.</p>
<p>Note that the event loop is detached from the actual player. Not calling <a class="el" href="#a14715be5aab817bb71770f711b64102a">mpv_wait_event()</a> will not stop playback. It will eventually congest the event queue of your API handle, though.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
Synchronous vs. asynchronous calls</h2>
<p>The API allows both synchronous and asynchronous calls. Synchronous calls have to wait until the playback core is ready, which currently can take an unbounded time (e.g. if network is slow or unresponsive). Asynchronous calls just queue operations as requests, and return the result of the operation as events.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
Asynchronous calls</h2>
<p>The client API includes asynchronous functions. These allow you to send requests instantly, and get replies as events at a later point. The requests are made with functions carrying the _async suffix, and replies are returned by <a class="el" href="#a14715be5aab817bb71770f711b64102a">mpv_wait_event()</a> (interleaved with the normal event stream).</p>
<p>A 64 bit userdata value is used to allow the user to associate requests with replies. The value is passed as reply_userdata parameter to the request function. The reply to the request will have the reply mpv_event-&gt;reply_userdata field set to the same value as the reply_userdata parameter of the corresponding request.</p>
<p>This userdata value is arbitrary and is never interpreted by the API. Note that the userdata value 0 is also allowed, but then the client must be careful not accidentally interpret the mpv_event-&gt;reply_userdata if an event is not a reply. (For non-replies, this field is set to 0.)</p>
<p>Asynchronous calls may be reordered in arbitrarily with other synchronous and asynchronous calls. If you want a guaranteed order, you need to wait until asynchronous calls report completion before doing the next call.</p>
<p>See also the section "Asynchronous command details" in the manpage.</p>
<h2><a class="anchor" id="autotoc_md5"></a>
Multithreading</h2>
<p>The client API is generally fully thread-safe, unless otherwise noted. Currently, there is no real advantage in using more than 1 thread to access the client API, since everything is serialized through a single lock in the playback core.</p>
<h2><a class="anchor" id="autotoc_md6"></a>
Basic environment requirements</h2>
<p>This documents basic requirements on the C environment. This is especially important if mpv is used as library with <a class="el" href="#acabb8d28abfb2614024eaa58a4de36e8">mpv_create()</a>.</p>
<ul>
<li>The LC_NUMERIC locale category must be set to "C". If your program calls setlocale(), be sure not to use LC_ALL, or if you do, reset LC_NUMERIC to its sane default: setlocale(LC_NUMERIC, "C").</li>
<li>If a X11 based VO is used, mpv will set the xlib error handler. This error handler is process-wide, and there's no proper way to share it with other xlib users within the same process. This might confuse GUI toolkits.</li>
<li>mpv uses some other libraries that are not library-safe, such as Fribidi (used through libass), ALSA, FFmpeg, and possibly more.</li>
<li>The FPU precision must be set at least to double precision.</li>
<li>On Windows, mpv will call timeBeginPeriod(1).</li>
<li>On memory exhaustion, mpv will kill the process.</li>
<li>In certain cases, mpv may start sub processes (such as with the ytdl wrapper script).</li>
<li>Using UNIX IPC (off by default) will override the SIGPIPE signal handler, and set it to SIG_IGN. Some invocations of the "subprocess" command will also do that.</li>
<li>mpv may start sub processes, so overriding SIGCHLD, or waiting on all PIDs (such as calling wait()) by the parent process or any other library within the process must be avoided. mpv itself only waits for its own PIDs.</li>
<li>If anything in the process registers signal handlers, they must set the SA_RESTART flag. Otherwise you WILL get random failures on signals.</li>
</ul>
<h2><a class="anchor" id="autotoc_md7"></a>
Encoding of filenames</h2>
<p>mpv uses UTF-8 everywhere.</p>
<p>On some platforms (like Linux), filenames actually do not have to be UTF-8; for this reason mpv supports non-UTF-8 strings. mpv uses what the kernel uses and does not recode filenames. At least on Linux, passing a string to mpv is like passing a string to the fopen() function.</p>
<p>On Windows, filenames are always UTF-8, mpv converts between UTF-8 and UTF-16 when using win32 API functions. mpv never uses or accepts filenames in the local 8 bit encoding. It does not use fopen() either; it uses _wfopen().</p>
<p>On OS X, filenames and other strings taken/returned by mpv can have inconsistent unicode normalization. This can sometimes lead to problems. You have to hope for the best.</p>
<p>Also see the remarks for MPV_FORMAT_STRING.</p>
<h2><a class="anchor" id="autotoc_md8"></a>
Embedding the video window</h2>
<p>Using the render API (in <a class="el" href="render_8h.html">render.h</a>) is recommended. This API requires you to create and maintain an OpenGL context, to which you can render video using a specific API call. This API does not include keyboard or mouse input directly.</p>
<p>There is an older way to embed the native mpv window into your own. You have to get the raw window handle, and set it as "wid" option. This works on X11, win32, and OSX only. It's much easier to use than the render API, but also has various problems.</p>
<p>Also see client API examples and the mpv manpage. There is an extensive discussion here: <a href="https://github.com/mpv-player/mpv-examples/tree/master/mpv#methods-of-embedding-the-video-window">https://github.com/mpv-player/mpv-examples/tree/master/mpv#methods-of-embedding-the-video-window</a></p>
<h2><a class="anchor" id="autotoc_md9"></a>
Compatibility</h2>
<p>mpv development doesn't stand still, and changes to mpv internals as well as to its interface can cause compatibility issues to client API users.</p>
<p>The API is versioned (see MPV_CLIENT_API_VERSION), and changes to it are documented in DOCS/client-api-changes.rst. The C API itself will probably remain compatible for a long time, but the functionality exposed by it could change more rapidly. For example, it's possible that options are renamed, or change the set of allowed values.</p>
<p>Defensive programming should be used to potentially deal with the fact that options, commands, and properties could disappear, change their value range, or change the underlying datatypes. It might be a good idea to prefer MPV_FORMAT_STRING over other types to decouple your code from potential mpv changes.</p>
<p>Also see: DOCS/compatibility.rst</p>
<h2><a class="anchor" id="autotoc_md10"></a>
Future changes</h2>
<p>This are the planned changes that will most likely be done on the next major bump of the library:</p>
<ul>
<li>remove all symbols that are marked as deprecated</li>
<li>reassign enum numerical values to remove gaps</li>
<li>disabling all events by default The version is incremented on each API change. The 16 lower bits form the minor version number, and the 16 higher bits the major version number. If the API becomes incompatible to previous versions, the major version number is incremented. This affects only C part, and not properties and options.</li>
</ul>
<p>Every API bump is described in DOCS/client-api-changes.rst</p>
<p>You can use <a class="el" href="#a8f9935d5ba969afe3bd22bb67e2759a1">MPV_MAKE_VERSION()</a> and compare the result with integer relational operators (&lt;, &gt;, &lt;=, &gt;=). </p>

<p class="definition">在文件 <a class="el" href="client_8h_source.html">client.h</a> 第 <a class="el" href="client_8h_source.html#l00250">250</a> 行定义.</p>

</div>
</div>
<a id="a987fd04fa0aa4df3e3af33f9f41a18da" name="a987fd04fa0aa4df3e3af33f9f41a18da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a987fd04fa0aa4df3e3af33f9f41a18da">&#9670;&#160;</a></span>MPV_SELECTANY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MPV_SELECTANY</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">在文件 <a class="el" href="client_8h_source.html">client.h</a> 第 <a class="el" href="client_8h_source.html#l00037">37</a> 行定义.</p>

</div>
</div>
<h2 class="groupheader">类型定义说明</h2>
<a id="ab81c48c60fc42fdd033fbd58a461102a" name="ab81c48c60fc42fdd033fbd58a461102a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab81c48c60fc42fdd033fbd58a461102a">&#9670;&#160;</a></span>mpv_byte_array</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct mpv_byte_array mpv_byte_array</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>(see <a class="el" href="structmpv__node.html">mpv_node</a>) </p>

</div>
</div>
<a id="a82ccaf3c5f76032eeca204fea40bbfb0" name="a82ccaf3c5f76032eeca204fea40bbfb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82ccaf3c5f76032eeca204fea40bbfb0">&#9670;&#160;</a></span>mpv_end_file_reason</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="#a888a4fa4a307ad54ec74e5f4a5862f1d">mpv_end_file_reason</a> <a class="el" href="#a888a4fa4a307ad54ec74e5f4a5862f1d">mpv_end_file_reason</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Since API version 1.9. </p>

</div>
</div>
<a id="aefc7e04d0d96db37a2c3dbf8b5cd2d76" name="aefc7e04d0d96db37a2c3dbf8b5cd2d76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefc7e04d0d96db37a2c3dbf8b5cd2d76">&#9670;&#160;</a></span>mpv_error</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="#ae3ecabf6277821768141a86e5fad779f">mpv_error</a> <a class="el" href="#ae3ecabf6277821768141a86e5fad779f">mpv_error</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>List of error codes than can be returned by API functions. 0 and positive return values always mean success, negative values are always errors. </p>

</div>
</div>
<a id="a08e83267caf73a2a25e7302569537fc1" name="a08e83267caf73a2a25e7302569537fc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08e83267caf73a2a25e7302569537fc1">&#9670;&#160;</a></span>mpv_event</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct mpv_event mpv_event</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a992a187ef3668df17d913f9297aaef0a" name="a992a187ef3668df17d913f9297aaef0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a992a187ef3668df17d913f9297aaef0a">&#9670;&#160;</a></span>mpv_event_client_message</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct mpv_event_client_message mpv_event_client_message</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4cddceaeb1a3e52f0ee7816b01354802" name="a4cddceaeb1a3e52f0ee7816b01354802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cddceaeb1a3e52f0ee7816b01354802">&#9670;&#160;</a></span>mpv_event_command</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct mpv_event_command mpv_event_command</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e162478350b4b363ca6c7ebdfd4799a" name="a4e162478350b4b363ca6c7ebdfd4799a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e162478350b4b363ca6c7ebdfd4799a">&#9670;&#160;</a></span>mpv_event_end_file</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct mpv_event_end_file mpv_event_end_file</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af58e67c1c4e759e47b45aa986126500a" name="af58e67c1c4e759e47b45aa986126500a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af58e67c1c4e759e47b45aa986126500a">&#9670;&#160;</a></span>mpv_event_hook</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct mpv_event_hook mpv_event_hook</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a135d0130e68283ee6f934d18dcfba646" name="a135d0130e68283ee6f934d18dcfba646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a135d0130e68283ee6f934d18dcfba646">&#9670;&#160;</a></span>mpv_event_id</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="#aab05e07858ef82e9c08f7e3727f5d40c">mpv_event_id</a> <a class="el" href="#aab05e07858ef82e9c08f7e3727f5d40c">mpv_event_id</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af1308c0ba51f270d39aae244705d8132" name="af1308c0ba51f270d39aae244705d8132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1308c0ba51f270d39aae244705d8132">&#9670;&#160;</a></span>mpv_event_log_message</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct mpv_event_log_message mpv_event_log_message</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad536827cd31aefcccd1e2339adbfed3d" name="ad536827cd31aefcccd1e2339adbfed3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad536827cd31aefcccd1e2339adbfed3d">&#9670;&#160;</a></span>mpv_event_property</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct mpv_event_property mpv_event_property</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a37d52be4b3d145102c88501d83a6ec61" name="a37d52be4b3d145102c88501d83a6ec61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37d52be4b3d145102c88501d83a6ec61">&#9670;&#160;</a></span>mpv_event_start_file</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct mpv_event_start_file mpv_event_start_file</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Since API version 1.108. </p>

</div>
</div>
<a id="a6f07dc2039f1f12f018a803c40d3fdd5" name="a6f07dc2039f1f12f018a803c40d3fdd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f07dc2039f1f12f018a803c40d3fdd5">&#9670;&#160;</a></span>mpv_format</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="#a8de0a5cfaeed2adfe0c344df68ba292f">mpv_format</a> <a class="el" href="#a8de0a5cfaeed2adfe0c344df68ba292f">mpv_format</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data format for options and properties. The API functions to get/set properties and options support multiple formats, and this enum describes them. </p>

</div>
</div>
<a id="a93d313a21048fe10f1edd9b03e05d416" name="a93d313a21048fe10f1edd9b03e05d416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93d313a21048fe10f1edd9b03e05d416">&#9670;&#160;</a></span>mpv_handle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> <a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Client context used by the client API. Every client has its own private handle. </p>

<p class="definition">在文件 <a class="el" href="client_8h_source.html">client.h</a> 第 <a class="el" href="client_8h_source.html#l00272">272</a> 行定义.</p>

</div>
</div>
<a id="a0df1b3a994878c6c26428f0b6d164c51" name="a0df1b3a994878c6c26428f0b6d164c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0df1b3a994878c6c26428f0b6d164c51">&#9670;&#160;</a></span>mpv_log_level</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="#a53ff39f9b884d7bc6dd30bd612365ae9">mpv_log_level</a> <a class="el" href="#a53ff39f9b884d7bc6dd30bd612365ae9">mpv_log_level</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Numeric log levels. The lower the number, the more important the message is. MPV_LOG_LEVEL_NONE is never used when receiving messages. The string in the comment after the value is the name of the log level as used for the <a class="el" href="#a2cd1f2768f461a351a1d8ad345539492">mpv_request_log_messages()</a> function. Unused numeric values are unused, but reserved for future use. </p>

</div>
</div>
<a id="a193131c36f988b34d2b3808930d6fe2b" name="a193131c36f988b34d2b3808930d6fe2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a193131c36f988b34d2b3808930d6fe2b">&#9670;&#160;</a></span>mpv_node</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct mpv_node mpv_node</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generic data storage.</p>
<p>If mpv writes this struct (e.g. via <a class="el" href="#aeca58b3b9eadb3cd70953d9cba238958">mpv_get_property()</a>), you must not change the data. In some cases (<a class="el" href="#aeca58b3b9eadb3cd70953d9cba238958">mpv_get_property()</a>), you have to free it with <a class="el" href="#a4dc4983d9482000f58cd14ee66cdf8ba">mpv_free_node_contents()</a>. If you fill this struct yourself, you're also responsible for freeing it, and you must not call <a class="el" href="#a4dc4983d9482000f58cd14ee66cdf8ba">mpv_free_node_contents()</a>. </p>

</div>
</div>
<a id="abd793adbb96bc3dd85572dbbf242f2a6" name="abd793adbb96bc3dd85572dbbf242f2a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd793adbb96bc3dd85572dbbf242f2a6">&#9670;&#160;</a></span>mpv_node_list</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct mpv_node_list mpv_node_list</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>(see <a class="el" href="structmpv__node.html">mpv_node</a>) </p>

</div>
</div>
<h2 class="groupheader">枚举类型说明</h2>
<a id="a888a4fa4a307ad54ec74e5f4a5862f1d" name="a888a4fa4a307ad54ec74e5f4a5862f1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a888a4fa4a307ad54ec74e5f4a5862f1d">&#9670;&#160;</a></span>mpv_end_file_reason</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a888a4fa4a307ad54ec74e5f4a5862f1d">mpv_end_file_reason</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Since API version 1.9. </p>
<table class="fieldtable">
<tr><th colspan="2">枚举值</th></tr><tr><td class="fieldname"><a id="a888a4fa4a307ad54ec74e5f4a5862f1da10573a7dc2c64799d2bce2bed3b6071c" name="a888a4fa4a307ad54ec74e5f4a5862f1da10573a7dc2c64799d2bce2bed3b6071c"></a>MPV_END_FILE_REASON_EOF&#160;</td><td class="fielddoc"><p>The end of file was reached. Sometimes this may also happen on incomplete or corrupted files, or if the network connection was interrupted when playing a remote file. It also happens if the playback range was restricted with &ndash;end or &ndash;frames or similar. </p>
</td></tr>
<tr><td class="fieldname"><a id="a888a4fa4a307ad54ec74e5f4a5862f1da58885a49994cc7ace30e78b1d279963b" name="a888a4fa4a307ad54ec74e5f4a5862f1da58885a49994cc7ace30e78b1d279963b"></a>MPV_END_FILE_REASON_STOP&#160;</td><td class="fielddoc"><p>Playback was stopped by an external action (e.g. playlist controls). </p>
</td></tr>
<tr><td class="fieldname"><a id="a888a4fa4a307ad54ec74e5f4a5862f1da0248e0f6cde8b8bf64a612721086481d" name="a888a4fa4a307ad54ec74e5f4a5862f1da0248e0f6cde8b8bf64a612721086481d"></a>MPV_END_FILE_REASON_QUIT&#160;</td><td class="fielddoc"><p>Playback was stopped by the quit command or player shutdown. </p>
</td></tr>
<tr><td class="fieldname"><a id="a888a4fa4a307ad54ec74e5f4a5862f1da1c6617645e83398ca8876254d276be06" name="a888a4fa4a307ad54ec74e5f4a5862f1da1c6617645e83398ca8876254d276be06"></a>MPV_END_FILE_REASON_ERROR&#160;</td><td class="fielddoc"><p>Some kind of error happened that lead to playback abort. Does not necessarily happen on incomplete or broken files (in these cases, both MPV_END_FILE_REASON_ERROR or MPV_END_FILE_REASON_EOF are possible).</p>
<p><a class="el" href="structmpv__event__end__file.html#a31edd444294ba158d5891a78a28ad494">mpv_event_end_file.error</a> will be set. </p>
</td></tr>
<tr><td class="fieldname"><a id="a888a4fa4a307ad54ec74e5f4a5862f1da99bc85aa86b2fc54e6bf7fa4c81733d4" name="a888a4fa4a307ad54ec74e5f4a5862f1da99bc85aa86b2fc54e6bf7fa4c81733d4"></a>MPV_END_FILE_REASON_REDIRECT&#160;</td><td class="fielddoc"><p>The file was a playlist or similar. When the playlist is read, its entries will be appended to the playlist after the entry of the current file, the entry of the current file is removed, and a MPV_EVENT_END_FILE event is sent with reason set to MPV_END_FILE_REASON_REDIRECT. Then playback continues with the playlist contents. Since API version 1.18. </p>
</td></tr>
</table>

<p class="definition">在文件 <a class="el" href="client_8h_source.html">client.h</a> 第 <a class="el" href="client_8h_source.html#l01461">1461</a> 行定义.</p>

</div>
</div>
<a id="ae3ecabf6277821768141a86e5fad779f" name="ae3ecabf6277821768141a86e5fad779f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3ecabf6277821768141a86e5fad779f">&#9670;&#160;</a></span>mpv_error</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ae3ecabf6277821768141a86e5fad779f">mpv_error</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>List of error codes than can be returned by API functions. 0 and positive return values always mean success, negative values are always errors. </p>
<table class="fieldtable">
<tr><th colspan="2">枚举值</th></tr><tr><td class="fieldname"><a id="ae3ecabf6277821768141a86e5fad779fae4b8c4f440e1c6e3e1e35b15850902d7" name="ae3ecabf6277821768141a86e5fad779fae4b8c4f440e1c6e3e1e35b15850902d7"></a>MPV_ERROR_SUCCESS&#160;</td><td class="fielddoc"><p>No error happened (used to signal successful operation). Keep in mind that many API functions returning error codes can also return positive values, which also indicate success. API users can hardcode the fact that "&gt;= 0" means success. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae3ecabf6277821768141a86e5fad779fa7eeb3ee291759d6a7edacf5be26bf7dc" name="ae3ecabf6277821768141a86e5fad779fa7eeb3ee291759d6a7edacf5be26bf7dc"></a>MPV_ERROR_EVENT_QUEUE_FULL&#160;</td><td class="fielddoc"><p>The event ringbuffer is full. This means the client is choked, and can't receive any events. This can happen when too many asynchronous requests have been made, but not answered. Probably never happens in practice, unless the mpv core is frozen for some reason, and the client keeps making asynchronous requests. (Bugs in the client API implementation could also trigger this, e.g. if events become "lost".) </p>
</td></tr>
<tr><td class="fieldname"><a id="ae3ecabf6277821768141a86e5fad779fac1ec769fb8e8e32db4be14cb378a9cc5" name="ae3ecabf6277821768141a86e5fad779fac1ec769fb8e8e32db4be14cb378a9cc5"></a>MPV_ERROR_NOMEM&#160;</td><td class="fielddoc"><p>Memory allocation failed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae3ecabf6277821768141a86e5fad779fa6bddd4b8e3060f3e1e2f25e89e8828fe" name="ae3ecabf6277821768141a86e5fad779fa6bddd4b8e3060f3e1e2f25e89e8828fe"></a>MPV_ERROR_UNINITIALIZED&#160;</td><td class="fielddoc"><p>The mpv core wasn't configured and initialized yet. See the notes in <a class="el" href="#acabb8d28abfb2614024eaa58a4de36e8">mpv_create()</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae3ecabf6277821768141a86e5fad779fa6759d447b337febf1348151b3e31cc7b" name="ae3ecabf6277821768141a86e5fad779fa6759d447b337febf1348151b3e31cc7b"></a>MPV_ERROR_INVALID_PARAMETER&#160;</td><td class="fielddoc"><p>Generic catch-all error if a parameter is set to an invalid or unsupported value. This is used if there is no better error code. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae3ecabf6277821768141a86e5fad779faa0b5d95c5ba90a734b25afff64001d2e" name="ae3ecabf6277821768141a86e5fad779faa0b5d95c5ba90a734b25afff64001d2e"></a>MPV_ERROR_OPTION_NOT_FOUND&#160;</td><td class="fielddoc"><p>Trying to set an option that doesn't exist. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae3ecabf6277821768141a86e5fad779fae0d43d853df62b97334a74d431839e9e" name="ae3ecabf6277821768141a86e5fad779fae0d43d853df62b97334a74d431839e9e"></a>MPV_ERROR_OPTION_FORMAT&#160;</td><td class="fielddoc"><p>Trying to set an option using an unsupported MPV_FORMAT. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae3ecabf6277821768141a86e5fad779fae44979d46f05dbd66878df705977980d" name="ae3ecabf6277821768141a86e5fad779fae44979d46f05dbd66878df705977980d"></a>MPV_ERROR_OPTION_ERROR&#160;</td><td class="fielddoc"><p>Setting the option failed. Typically this happens if the provided option value could not be parsed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae3ecabf6277821768141a86e5fad779fad1e39800ef57dcc7f2cc86cd82f99220" name="ae3ecabf6277821768141a86e5fad779fad1e39800ef57dcc7f2cc86cd82f99220"></a>MPV_ERROR_PROPERTY_NOT_FOUND&#160;</td><td class="fielddoc"><p>The accessed property doesn't exist. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae3ecabf6277821768141a86e5fad779fa585e54b40613281530f2e74821b6ff27" name="ae3ecabf6277821768141a86e5fad779fa585e54b40613281530f2e74821b6ff27"></a>MPV_ERROR_PROPERTY_FORMAT&#160;</td><td class="fielddoc"><p>Trying to set or get a property using an unsupported MPV_FORMAT. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae3ecabf6277821768141a86e5fad779fa72a320b2fd86de980fb7ad35cd70fc1d" name="ae3ecabf6277821768141a86e5fad779fa72a320b2fd86de980fb7ad35cd70fc1d"></a>MPV_ERROR_PROPERTY_UNAVAILABLE&#160;</td><td class="fielddoc"><p>The property exists, but is not available. This usually happens when the associated subsystem is not active, e.g. querying audio parameters while audio is disabled. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae3ecabf6277821768141a86e5fad779fa3cb278a68a3b842d01cfd379fd9af145" name="ae3ecabf6277821768141a86e5fad779fa3cb278a68a3b842d01cfd379fd9af145"></a>MPV_ERROR_PROPERTY_ERROR&#160;</td><td class="fielddoc"><p>Error setting or getting a property. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae3ecabf6277821768141a86e5fad779fa498aeb7d75d4e6e6fb705fa20352c523" name="ae3ecabf6277821768141a86e5fad779fa498aeb7d75d4e6e6fb705fa20352c523"></a>MPV_ERROR_COMMAND&#160;</td><td class="fielddoc"><p>General error when running a command with mpv_command and similar. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae3ecabf6277821768141a86e5fad779fa356d084931199d04f5b127ae16f6ed76" name="ae3ecabf6277821768141a86e5fad779fa356d084931199d04f5b127ae16f6ed76"></a>MPV_ERROR_LOADING_FAILED&#160;</td><td class="fielddoc"><p>Generic error on loading (usually used with <a class="el" href="structmpv__event__end__file.html#a31edd444294ba158d5891a78a28ad494">mpv_event_end_file.error</a>). </p>
</td></tr>
<tr><td class="fieldname"><a id="ae3ecabf6277821768141a86e5fad779fab33d5950518338439ada112af53d9801" name="ae3ecabf6277821768141a86e5fad779fab33d5950518338439ada112af53d9801"></a>MPV_ERROR_AO_INIT_FAILED&#160;</td><td class="fielddoc"><p>Initializing the audio output failed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae3ecabf6277821768141a86e5fad779fa69ca882ff793b2bb7d32e32b58471d0b" name="ae3ecabf6277821768141a86e5fad779fa69ca882ff793b2bb7d32e32b58471d0b"></a>MPV_ERROR_VO_INIT_FAILED&#160;</td><td class="fielddoc"><p>Initializing the video output failed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae3ecabf6277821768141a86e5fad779fab2e56f0ceef984b32cb5c85fc39d7e34" name="ae3ecabf6277821768141a86e5fad779fab2e56f0ceef984b32cb5c85fc39d7e34"></a>MPV_ERROR_NOTHING_TO_PLAY&#160;</td><td class="fielddoc"><p>There was no audio or video data to play. This also happens if the file was recognized, but did not contain any audio or video streams, or no streams were selected. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae3ecabf6277821768141a86e5fad779fa47210404529fb770cce5760de18f1a22" name="ae3ecabf6277821768141a86e5fad779fa47210404529fb770cce5760de18f1a22"></a>MPV_ERROR_UNKNOWN_FORMAT&#160;</td><td class="fielddoc"><p>When trying to load the file, the file format could not be determined, or the file was too broken to open it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae3ecabf6277821768141a86e5fad779fa0c4873c88cf49bb05ffbd1ce7e81d99b" name="ae3ecabf6277821768141a86e5fad779fa0c4873c88cf49bb05ffbd1ce7e81d99b"></a>MPV_ERROR_UNSUPPORTED&#160;</td><td class="fielddoc"><p>Generic error for signaling that certain system requirements are not fulfilled. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae3ecabf6277821768141a86e5fad779fa189f2f9013fb236a39ba49beb36acd1f" name="ae3ecabf6277821768141a86e5fad779fa189f2f9013fb236a39ba49beb36acd1f"></a>MPV_ERROR_NOT_IMPLEMENTED&#160;</td><td class="fielddoc"><p>The API function which was called is a stub only. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae3ecabf6277821768141a86e5fad779fa455ae6916f3f9c863f1611e12575f0d9" name="ae3ecabf6277821768141a86e5fad779fa455ae6916f3f9c863f1611e12575f0d9"></a>MPV_ERROR_GENERIC&#160;</td><td class="fielddoc"><p>Unspecified error. </p>
</td></tr>
</table>

<p class="definition">在文件 <a class="el" href="client_8h_source.html">client.h</a> 第 <a class="el" href="client_8h_source.html#l00278">278</a> 行定义.</p>

</div>
</div>
<a id="aab05e07858ef82e9c08f7e3727f5d40c" name="aab05e07858ef82e9c08f7e3727f5d40c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab05e07858ef82e9c08f7e3727f5d40c">&#9670;&#160;</a></span>mpv_event_id</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#aab05e07858ef82e9c08f7e3727f5d40c">mpv_event_id</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">枚举值</th></tr><tr><td class="fieldname"><a id="aab05e07858ef82e9c08f7e3727f5d40ca8fcfbc9e8dd1e3d06c2ebda6abaa7a0f" name="aab05e07858ef82e9c08f7e3727f5d40ca8fcfbc9e8dd1e3d06c2ebda6abaa7a0f"></a>MPV_EVENT_NONE&#160;</td><td class="fielddoc"><p>Nothing happened. Happens on timeouts or sporadic wakeups. </p>
</td></tr>
<tr><td class="fieldname"><a id="aab05e07858ef82e9c08f7e3727f5d40ca528dd526c9db22231c27181d97e66e5b" name="aab05e07858ef82e9c08f7e3727f5d40ca528dd526c9db22231c27181d97e66e5b"></a>MPV_EVENT_SHUTDOWN&#160;</td><td class="fielddoc"><p>Happens when the player quits. The player enters a state where it tries to disconnect all clients. Most requests to the player will fail, and the client should react to this and quit with <a class="el" href="#ae12b97104f3bbe302d96260c33728f07">mpv_destroy()</a> as soon as possible. </p>
</td></tr>
<tr><td class="fieldname"><a id="aab05e07858ef82e9c08f7e3727f5d40caba2305825e4f242faebd9b1b53c0923f" name="aab05e07858ef82e9c08f7e3727f5d40caba2305825e4f242faebd9b1b53c0923f"></a>MPV_EVENT_LOG_MESSAGE&#160;</td><td class="fielddoc"><p>See <a class="el" href="#a2cd1f2768f461a351a1d8ad345539492">mpv_request_log_messages()</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="aab05e07858ef82e9c08f7e3727f5d40ca425bb5605d4009120e95a51f6417e086" name="aab05e07858ef82e9c08f7e3727f5d40ca425bb5605d4009120e95a51f6417e086"></a>MPV_EVENT_GET_PROPERTY_REPLY&#160;</td><td class="fielddoc"><p>Reply to a <a class="el" href="#a08d2ef781815c9eea2614d5267c7cf6e">mpv_get_property_async()</a> request. See also <a class="el" href="structmpv__event.html">mpv_event</a> and <a class="el" href="structmpv__event__property.html">mpv_event_property</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="aab05e07858ef82e9c08f7e3727f5d40cadbcd7440b0551b94a46e459be407c10d" name="aab05e07858ef82e9c08f7e3727f5d40cadbcd7440b0551b94a46e459be407c10d"></a>MPV_EVENT_SET_PROPERTY_REPLY&#160;</td><td class="fielddoc"><p>Reply to a <a class="el" href="#af3df8b17cb495fb877af6957520df0ed">mpv_set_property_async()</a> request. (Unlike MPV_EVENT_GET_PROPERTY, <a class="el" href="structmpv__event__property.html">mpv_event_property</a> is not used.) </p>
</td></tr>
<tr><td class="fieldname"><a id="aab05e07858ef82e9c08f7e3727f5d40ca8956f1fff5127c3766f31c349331e3fe" name="aab05e07858ef82e9c08f7e3727f5d40ca8956f1fff5127c3766f31c349331e3fe"></a>MPV_EVENT_COMMAND_REPLY&#160;</td><td class="fielddoc"><p>Reply to a <a class="el" href="#aa0eb9659d717174434d6c69bb0be089b">mpv_command_async()</a> or <a class="el" href="#a3b980e553adb8231b396555c6c8c8490">mpv_command_node_async()</a> request. See also <a class="el" href="structmpv__event.html">mpv_event</a> and <a class="el" href="structmpv__event__command.html">mpv_event_command</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="aab05e07858ef82e9c08f7e3727f5d40ca929c29b70b43b54bc2f365496da3f292" name="aab05e07858ef82e9c08f7e3727f5d40ca929c29b70b43b54bc2f365496da3f292"></a>MPV_EVENT_START_FILE&#160;</td><td class="fielddoc"><p>Notification before playback start of a file (before the file is loaded). See also <a class="el" href="structmpv__event.html">mpv_event</a> and <a class="el" href="structmpv__event__start__file.html" title="Since API version 1.108.">mpv_event_start_file</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="aab05e07858ef82e9c08f7e3727f5d40ca07d453b2bf4aad8682b5333fe8ccefd6" name="aab05e07858ef82e9c08f7e3727f5d40ca07d453b2bf4aad8682b5333fe8ccefd6"></a>MPV_EVENT_END_FILE&#160;</td><td class="fielddoc"><p>Notification after playback end (after the file was unloaded). See also <a class="el" href="structmpv__event.html">mpv_event</a> and <a class="el" href="structmpv__event__end__file.html">mpv_event_end_file</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="aab05e07858ef82e9c08f7e3727f5d40ca70282f17d5fd70607d43ae39149da16e" name="aab05e07858ef82e9c08f7e3727f5d40ca70282f17d5fd70607d43ae39149da16e"></a>MPV_EVENT_FILE_LOADED&#160;</td><td class="fielddoc"><p>Notification when the file has been loaded (headers were read etc.), and decoding starts. </p>
</td></tr>
<tr><td class="fieldname"><a id="aab05e07858ef82e9c08f7e3727f5d40cacca46466ad6358939a65946b90bd4576" name="aab05e07858ef82e9c08f7e3727f5d40cacca46466ad6358939a65946b90bd4576"></a>MPV_EVENT_IDLE&#160;</td><td class="fielddoc"><p>Idle mode was entered. In this mode, no file is played, and the playback core waits for new commands. (The command line player normally quits instead of entering idle mode, unless &ndash;idle was specified. If mpv was started with <a class="el" href="#acabb8d28abfb2614024eaa58a4de36e8">mpv_create()</a>, idle mode is enabled by default.)</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">弃用</a></b></dt><dd>This is equivalent to using <a class="el" href="#af3d2b287c0f994fb3649c1a1bf85591e">mpv_observe_property()</a> on the "idle-active" property. The event is redundant, and might be removed in the far future. As a further warning, this event is not necessarily sent at the right point anymore (at the start of the program), while the property behaves correctly. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="aab05e07858ef82e9c08f7e3727f5d40ca6717605195a003a3a832df83cb4f622f" name="aab05e07858ef82e9c08f7e3727f5d40ca6717605195a003a3a832df83cb4f622f"></a>MPV_EVENT_TICK&#160;</td><td class="fielddoc"><p>Sent every time after a video frame is displayed. Note that currently, this will be sent in lower frequency if there is no video, or playback is paused - but that will be removed in the future, and it will be restricted to video frames only.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">弃用</a></b></dt><dd>Use <a class="el" href="#af3d2b287c0f994fb3649c1a1bf85591e">mpv_observe_property()</a> with relevant properties instead (such as "playback-time"). </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="aab05e07858ef82e9c08f7e3727f5d40ca65cffe5cbfad29019d3c8661ffa44e68" name="aab05e07858ef82e9c08f7e3727f5d40ca65cffe5cbfad29019d3c8661ffa44e68"></a>MPV_EVENT_CLIENT_MESSAGE&#160;</td><td class="fielddoc"><p>Triggered by the script-message input command. The command uses the first argument of the command as client name (see <a class="el" href="#a6ed74ba4e80320ee0a9b16cba220ff4d">mpv_client_name()</a>) to dispatch the message, and passes along all arguments starting from the second argument as strings. See also <a class="el" href="structmpv__event.html">mpv_event</a> and <a class="el" href="structmpv__event__client__message.html">mpv_event_client_message</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="aab05e07858ef82e9c08f7e3727f5d40ca5a15cd0e9004fe93dc63b3577a09963d" name="aab05e07858ef82e9c08f7e3727f5d40ca5a15cd0e9004fe93dc63b3577a09963d"></a>MPV_EVENT_VIDEO_RECONFIG&#160;</td><td class="fielddoc"><p>Happens after video changed in some way. This can happen on resolution changes, pixel format changes, or video filter changes. The event is sent after the video filters and the VO are reconfigured. Applications embedding a mpv window should listen to this event in order to resize the window if needed. Note that this event can happen sporadically, and you should check yourself whether the video parameters really changed before doing something expensive. </p>
</td></tr>
<tr><td class="fieldname"><a id="aab05e07858ef82e9c08f7e3727f5d40cada5daf7400912e10335adc938be117b4" name="aab05e07858ef82e9c08f7e3727f5d40cada5daf7400912e10335adc938be117b4"></a>MPV_EVENT_AUDIO_RECONFIG&#160;</td><td class="fielddoc"><p>Similar to MPV_EVENT_VIDEO_RECONFIG. This is relatively uninteresting, because there is no such thing as audio output embedding. </p>
</td></tr>
<tr><td class="fieldname"><a id="aab05e07858ef82e9c08f7e3727f5d40ca71d61460b78ec87065abc5f8534fec53" name="aab05e07858ef82e9c08f7e3727f5d40ca71d61460b78ec87065abc5f8534fec53"></a>MPV_EVENT_SEEK&#160;</td><td class="fielddoc"><p>Happens when a seek was initiated. Playback stops. Usually it will resume with MPV_EVENT_PLAYBACK_RESTART as soon as the seek is finished. </p>
</td></tr>
<tr><td class="fieldname"><a id="aab05e07858ef82e9c08f7e3727f5d40cadd91d1ffd840031176fe18004971f93e" name="aab05e07858ef82e9c08f7e3727f5d40cadd91d1ffd840031176fe18004971f93e"></a>MPV_EVENT_PLAYBACK_RESTART&#160;</td><td class="fielddoc"><p>There was a discontinuity of some sort (like a seek), and playback was reinitialized. Usually happens on start of playback and after seeking. The main purpose is allowing the client to detect when a seek request is finished. </p>
</td></tr>
<tr><td class="fieldname"><a id="aab05e07858ef82e9c08f7e3727f5d40ca22001e3203cb76ab62c63da90d1e9128" name="aab05e07858ef82e9c08f7e3727f5d40ca22001e3203cb76ab62c63da90d1e9128"></a>MPV_EVENT_PROPERTY_CHANGE&#160;</td><td class="fielddoc"><p>Event sent due to <a class="el" href="#af3d2b287c0f994fb3649c1a1bf85591e">mpv_observe_property()</a>. See also <a class="el" href="structmpv__event.html">mpv_event</a> and <a class="el" href="structmpv__event__property.html">mpv_event_property</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="aab05e07858ef82e9c08f7e3727f5d40ca0049354fca7804792174194b44e238cc" name="aab05e07858ef82e9c08f7e3727f5d40ca0049354fca7804792174194b44e238cc"></a>MPV_EVENT_QUEUE_OVERFLOW&#160;</td><td class="fielddoc"><p>Happens if the internal per-mpv_handle ringbuffer overflows, and at least 1 event had to be dropped. This can happen if the client doesn't read the event queue quickly enough with <a class="el" href="#a14715be5aab817bb71770f711b64102a">mpv_wait_event()</a>, or if the client makes a very large number of asynchronous calls at once.</p>
<p>Event delivery will continue normally once this event was returned (this forces the client to empty the queue completely). </p>
</td></tr>
<tr><td class="fieldname"><a id="aab05e07858ef82e9c08f7e3727f5d40cae6dbcd25c3b4b4d6c2ab551e6f02eede" name="aab05e07858ef82e9c08f7e3727f5d40cae6dbcd25c3b4b4d6c2ab551e6f02eede"></a>MPV_EVENT_HOOK&#160;</td><td class="fielddoc"><p>Triggered if a hook handler was registered with <a class="el" href="#af96a59b780ea3a0d7cf01c71116e136f">mpv_hook_add()</a>, and the hook is invoked. If you receive this, you must handle it, and continue the hook with <a class="el" href="#a6dd7bc86098f32e660bda2c14ca2eda6">mpv_hook_continue()</a>. See also <a class="el" href="structmpv__event.html">mpv_event</a> and <a class="el" href="structmpv__event__hook.html">mpv_event_hook</a>. </p>
</td></tr>
</table>

<p class="definition">在文件 <a class="el" href="client_8h_source.html">client.h</a> 第 <a class="el" href="client_8h_source.html#l01242">1242</a> 行定义.</p>

</div>
</div>
<a id="a8de0a5cfaeed2adfe0c344df68ba292f" name="a8de0a5cfaeed2adfe0c344df68ba292f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8de0a5cfaeed2adfe0c344df68ba292f">&#9670;&#160;</a></span>mpv_format</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a8de0a5cfaeed2adfe0c344df68ba292f">mpv_format</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data format for options and properties. The API functions to get/set properties and options support multiple formats, and this enum describes them. </p>
<table class="fieldtable">
<tr><th colspan="2">枚举值</th></tr><tr><td class="fieldname"><a id="a8de0a5cfaeed2adfe0c344df68ba292fa6a7adaa924f7ca11428d43fd9e3dfddd" name="a8de0a5cfaeed2adfe0c344df68ba292fa6a7adaa924f7ca11428d43fd9e3dfddd"></a>MPV_FORMAT_NONE&#160;</td><td class="fielddoc"><p>Invalid. Sometimes used for empty values. This is always defined to 0, so a normal 0-init of mpv_format (or e.g. <a class="el" href="structmpv__node.html">mpv_node</a>) is guaranteed to set this it to MPV_FORMAT_NONE (which makes some things saner as consequence). </p>
</td></tr>
<tr><td class="fieldname"><a id="a8de0a5cfaeed2adfe0c344df68ba292fa5cc32ffe7bcb782694d9166d8706b02b" name="a8de0a5cfaeed2adfe0c344df68ba292fa5cc32ffe7bcb782694d9166d8706b02b"></a>MPV_FORMAT_STRING&#160;</td><td class="fielddoc"><p>The basic type is char*. It returns the raw property string, like using ${=property} in input.conf (see input.rst).</p>
<p>NULL isn't an allowed value.</p>
<p>Warning: although the encoding is usually UTF-8, this is not always the case. File tags often store strings in some legacy codepage, and even filenames don't necessarily have to be in UTF-8 (at least on Linux). If you pass the strings to code that requires valid UTF-8, you have to sanitize it in some way. On Windows, filenames are always UTF-8, and mpv converts between UTF-8 and UTF-16 when using win32 API functions. See the "Encoding of filenames" section for details.</p>
<p>Example for reading: </p><pre class="fragment">char *result = NULL;
if (mpv_get_property(ctx, "property", MPV_FORMAT_STRING, &amp;result) &lt; 0)
    goto error;
printf("%s\n", result);
mpv_free(result);
</pre><p> Or just use <a class="el" href="#a83f459695d01260a86ca746e1b50e39a">mpv_get_property_string()</a>.</p>
<p>Example for writing: </p><pre class="fragment">char *value = "the new value";
// yep, you pass the address to the variable
// (needed for symmetry with other types and mpv_get_property)
mpv_set_property(ctx, "property", MPV_FORMAT_STRING, &amp;value);
</pre><p> Or just use <a class="el" href="#a292257755e6b358b045254ef1e4534d8">mpv_set_property_string()</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8de0a5cfaeed2adfe0c344df68ba292fade7699590e8fea898fc1252b011d6886" name="a8de0a5cfaeed2adfe0c344df68ba292fade7699590e8fea898fc1252b011d6886"></a>MPV_FORMAT_OSD_STRING&#160;</td><td class="fielddoc"><p>The basic type is char*. It returns the OSD property string, like using ${property} in input.conf (see input.rst). In many cases, this is the same as the raw string, but in other cases it's formatted for display on OSD. It's intended to be human readable. Do not attempt to parse these strings.</p>
<p>Only valid when doing read access. The rest works like MPV_FORMAT_STRING. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8de0a5cfaeed2adfe0c344df68ba292fa8b91160f26b4055bc7d11d51ad5b330a" name="a8de0a5cfaeed2adfe0c344df68ba292fa8b91160f26b4055bc7d11d51ad5b330a"></a>MPV_FORMAT_FLAG&#160;</td><td class="fielddoc"><p>The basic type is int. The only allowed values are 0 ("no") and 1 ("yes").</p>
<p>Example for reading: </p><pre class="fragment">int result;
if (mpv_get_property(ctx, "property", MPV_FORMAT_FLAG, &amp;result) &lt; 0)
    goto error;
printf("%s\n", result ? "true" : "false");
</pre><p> Example for writing: </p><pre class="fragment">int flag = 1;
mpv_set_property(ctx, "property", MPV_FORMAT_FLAG, &amp;flag);
</pre> </td></tr>
<tr><td class="fieldname"><a id="a8de0a5cfaeed2adfe0c344df68ba292fa72f5f173309907653b822a3667cee129" name="a8de0a5cfaeed2adfe0c344df68ba292fa72f5f173309907653b822a3667cee129"></a>MPV_FORMAT_INT64&#160;</td><td class="fielddoc"><p>The basic type is int64_t. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8de0a5cfaeed2adfe0c344df68ba292faea4c9937759ab544e0a172261efa6d91" name="a8de0a5cfaeed2adfe0c344df68ba292faea4c9937759ab544e0a172261efa6d91"></a>MPV_FORMAT_DOUBLE&#160;</td><td class="fielddoc"><p>The basic type is double. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8de0a5cfaeed2adfe0c344df68ba292fab46e83affdfce6887cd381c2642faeb0" name="a8de0a5cfaeed2adfe0c344df68ba292fab46e83affdfce6887cd381c2642faeb0"></a>MPV_FORMAT_NODE&#160;</td><td class="fielddoc"><p>The type is <a class="el" href="structmpv__node.html">mpv_node</a>.</p>
<p>For reading, you usually would pass a pointer to a stack-allocated <a class="el" href="structmpv__node.html">mpv_node</a> value to mpv, and when you're done you call mpv_free_node_contents(&amp;node). You're expected not to write to the data - if you have to, copy it first (which you have to do manually).</p>
<p>For writing, you construct your own <a class="el" href="structmpv__node.html">mpv_node</a>, and pass a pointer to the API. The API will never write to your data (and copy it if needed), so you're free to use any form of allocation or memory management you like.</p>
<p>Warning: when reading, always check the <a class="el" href="structmpv__node.html#a846c0b500bc8863c30da4f3a4ed3555b">mpv_node.format</a> member. For example, properties might change their type in future versions of mpv, or sometimes even during runtime.</p>
<p>Example for reading: </p><pre class="fragment">mpv_node result;
if (mpv_get_property(ctx, "property", MPV_FORMAT_NODE, &amp;result) &lt; 0)
    goto error;
printf("format=%d\n", (int)result.format);
mpv_free_node_contents(&amp;result).
</pre><p> Example for writing: </p><pre class="fragment">mpv_node value;
value.format = MPV_FORMAT_STRING;
value.u.string = "hello";
mpv_set_property(ctx, "property", MPV_FORMAT_NODE, &amp;value);
</pre> </td></tr>
<tr><td class="fieldname"><a id="a8de0a5cfaeed2adfe0c344df68ba292faf42f8145b18decb18e792f8fbb45dc90" name="a8de0a5cfaeed2adfe0c344df68ba292faf42f8145b18decb18e792f8fbb45dc90"></a>MPV_FORMAT_NODE_ARRAY&#160;</td><td class="fielddoc"><p>Used with <a class="el" href="structmpv__node.html">mpv_node</a> only. Can usually not be used directly. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8de0a5cfaeed2adfe0c344df68ba292fa60621f73f6bf466bac85deca57aa733c" name="a8de0a5cfaeed2adfe0c344df68ba292fa60621f73f6bf466bac85deca57aa733c"></a>MPV_FORMAT_NODE_MAP&#160;</td><td class="fielddoc"><p>See MPV_FORMAT_NODE_ARRAY. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8de0a5cfaeed2adfe0c344df68ba292fa6662cf5d2f89511643d51531d3714e6f" name="a8de0a5cfaeed2adfe0c344df68ba292fa6662cf5d2f89511643d51531d3714e6f"></a>MPV_FORMAT_BYTE_ARRAY&#160;</td><td class="fielddoc"><p>A raw, untyped byte array. Only used only with <a class="el" href="structmpv__node.html">mpv_node</a>, and only in some very specific situations. (Some commands use it.) </p>
</td></tr>
</table>

<p class="definition">在文件 <a class="el" href="client_8h_source.html">client.h</a> 第 <a class="el" href="client_8h_source.html#l00630">630</a> 行定义.</p>

</div>
</div>
<a id="a53ff39f9b884d7bc6dd30bd612365ae9" name="a53ff39f9b884d7bc6dd30bd612365ae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53ff39f9b884d7bc6dd30bd612365ae9">&#9670;&#160;</a></span>mpv_log_level</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a53ff39f9b884d7bc6dd30bd612365ae9">mpv_log_level</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Numeric log levels. The lower the number, the more important the message is. MPV_LOG_LEVEL_NONE is never used when receiving messages. The string in the comment after the value is the name of the log level as used for the <a class="el" href="#a2cd1f2768f461a351a1d8ad345539492">mpv_request_log_messages()</a> function. Unused numeric values are unused, but reserved for future use. </p>
<table class="fieldtable">
<tr><th colspan="2">枚举值</th></tr><tr><td class="fieldname"><a id="a53ff39f9b884d7bc6dd30bd612365ae9a9fe29725ff35b9c9d9349f07dcf6a355" name="a53ff39f9b884d7bc6dd30bd612365ae9a9fe29725ff35b9c9d9349f07dcf6a355"></a>MPV_LOG_LEVEL_NONE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a53ff39f9b884d7bc6dd30bd612365ae9acbf42c9592b7fd2c809d0f6471311037" name="a53ff39f9b884d7bc6dd30bd612365ae9acbf42c9592b7fd2c809d0f6471311037"></a>MPV_LOG_LEVEL_FATAL&#160;</td><td class="fielddoc"><p>"no" - disable absolutely all messages </p>
</td></tr>
<tr><td class="fieldname"><a id="a53ff39f9b884d7bc6dd30bd612365ae9a9f50162077d5f3a05872399782204ff4" name="a53ff39f9b884d7bc6dd30bd612365ae9a9f50162077d5f3a05872399782204ff4"></a>MPV_LOG_LEVEL_ERROR&#160;</td><td class="fielddoc"><p>"fatal" - critical/aborting errors </p>
</td></tr>
<tr><td class="fieldname"><a id="a53ff39f9b884d7bc6dd30bd612365ae9a96b343079df13e95b8e13e094b556d01" name="a53ff39f9b884d7bc6dd30bd612365ae9a96b343079df13e95b8e13e094b556d01"></a>MPV_LOG_LEVEL_WARN&#160;</td><td class="fielddoc"><p>"error" - simple errors </p>
</td></tr>
<tr><td class="fieldname"><a id="a53ff39f9b884d7bc6dd30bd612365ae9ac131682b89bf88e09f26d59490cb8645" name="a53ff39f9b884d7bc6dd30bd612365ae9ac131682b89bf88e09f26d59490cb8645"></a>MPV_LOG_LEVEL_INFO&#160;</td><td class="fielddoc"><p>"warn" - possible problems </p>
</td></tr>
<tr><td class="fieldname"><a id="a53ff39f9b884d7bc6dd30bd612365ae9abe26075b2da0242469bc554b67f9bf4d" name="a53ff39f9b884d7bc6dd30bd612365ae9abe26075b2da0242469bc554b67f9bf4d"></a>MPV_LOG_LEVEL_V&#160;</td><td class="fielddoc"><p>"info" - informational message </p>
</td></tr>
<tr><td class="fieldname"><a id="a53ff39f9b884d7bc6dd30bd612365ae9aa11c4d0c660c1f02de5b3110e2d8901e" name="a53ff39f9b884d7bc6dd30bd612365ae9aa11c4d0c660c1f02de5b3110e2d8901e"></a>MPV_LOG_LEVEL_DEBUG&#160;</td><td class="fielddoc"><p>"v" - noisy informational message </p>
</td></tr>
<tr><td class="fieldname"><a id="a53ff39f9b884d7bc6dd30bd612365ae9a2119f36591c715b0710852c77b6f13dd" name="a53ff39f9b884d7bc6dd30bd612365ae9a2119f36591c715b0710852c77b6f13dd"></a>MPV_LOG_LEVEL_TRACE&#160;</td><td class="fielddoc"><p>"debug" - very noisy technical information </p>
</td></tr>
</table>

<p class="definition">在文件 <a class="el" href="client_8h_source.html">client.h</a> 第 <a class="el" href="client_8h_source.html#l01423">1423</a> 行定义.</p>

</div>
</div>
<h2 class="groupheader">函数说明</h2>
<a id="aad77571834b9234894246b294d1c72d8" name="aad77571834b9234894246b294d1c72d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad77571834b9234894246b294d1c72d8">&#9670;&#160;</a></span>mpv_abort_async_command()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> void mpv_abort_async_command </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>reply_userdata</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Signal to all async requests with the matching ID to abort. This affects the following API calls: </p><pre class="fragment"> mpv_command_async
 mpv_command_node_async
</pre><p> All of these functions take a reply_userdata parameter. This API function tells all requests with the matching reply_userdata value to try to return as soon as possible. If there are multiple requests with matching ID, it aborts all of them.</p>
<p>This API function is mostly asynchronous itself. It will not wait until the command is aborted. Instead, the command will terminate as usual, but with some work not done. How this is signaled depends on the specific command (for example, the "subprocess" command will indicate it by "killed_by_us" set to true in the result). How long it takes also depends on the situation. The aborting process is completely asynchronous.</p>
<p>Not all commands may support this functionality. In this case, this function will have no effect. The same is true if the request using the passed reply_userdata has already terminated, has not been started yet, or was never in use at all.</p>
<p>You have to be careful of race conditions: the time during which the abort request will be effective is <em>after</em> e.g. <a class="el" href="#aa0eb9659d717174434d6c69bb0be089b">mpv_command_async()</a> has returned, and before the command has signaled completion with MPV_EVENT_COMMAND_REPLY.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">reply_userdata</td><td>ID of the request to be aborted (see above) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a175393956041e67ae34f45b808d4409c" name="a175393956041e67ae34f45b808d4409c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a175393956041e67ae34f45b808d4409c">&#9670;&#160;</a></span>mpv_client_api_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> unsigned long mpv_client_api_version </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the MPV_CLIENT_API_VERSION the mpv source has been compiled with. </p>

</div>
</div>
<a id="a37f88479040dfe2d2a84e4024c0dce73" name="a37f88479040dfe2d2a84e4024c0dce73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37f88479040dfe2d2a84e4024c0dce73">&#9670;&#160;</a></span>mpv_client_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int64_t mpv_client_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the ID of this client handle. Every client has its own unique ID. This ID is never reused by the core, even if the mpv_handle at hand gets destroyed and new handles get allocated.</p>
<p>IDs are never 0 or negative.</p>
<p>Some mpv APIs (not necessarily all) accept a name in the form "@&lt;id&gt;" in addition of the proper <a class="el" href="#a6ed74ba4e80320ee0a9b16cba220ff4d">mpv_client_name()</a>, where "&lt;id&gt;" is the ID in decimal form (e.g. "@123"). For example, the "script-message-to" command takes the client name as first argument, but also accepts the client ID formatted in this manner.</p>
<dl class="section return"><dt>返回</dt><dd>The client ID. </dd></dl>

</div>
</div>
<a id="a6ed74ba4e80320ee0a9b16cba220ff4d" name="a6ed74ba4e80320ee0a9b16cba220ff4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ed74ba4e80320ee0a9b16cba220ff4d">&#9670;&#160;</a></span>mpv_client_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> const char * mpv_client_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the name of this client handle. Every client has its own unique name, which is mostly used for user interface purposes.</p>
<dl class="section return"><dt>返回</dt><dd>The client name. The string is read-only and is valid until the mpv_handle is destroyed. </dd></dl>

</div>
</div>
<a id="aa44c1102744f5fa60fec80747fc9b856" name="aa44c1102744f5fa60fec80747fc9b856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa44c1102744f5fa60fec80747fc9b856">&#9670;&#160;</a></span>mpv_command()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int mpv_command </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a command to the player. Commands are the same as those used in input.conf, except that this function takes parameters in a pre-split form.</p>
<p>The commands and their parameters are documented in input.rst.</p>
<p>Does not use OSD and string expansion by default (unlike <a class="el" href="#aeb8e995b0d83679a630ba4100a3b9ba9">mpv_command_string()</a> and input.conf).</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>NULL-terminated list of strings. Usually, the first item is the command, and the following items are arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>error code </dd></dl>
<div class="dynheader">
这是这个函数的调用关系图:</div>
<div class="dyncontent">
<div class="center"><img src="client_8h_aa44c1102744f5fa60fec80747fc9b856_icgraph.png" border="0" usemap="#aclient_8h_aa44c1102744f5fa60fec80747fc9b856_icgraph" alt=""/></div>
<map name="aclient_8h_aa44c1102744f5fa60fec80747fc9b856_icgraph" id="aclient_8h_aa44c1102744f5fa60fec80747fc9b856_icgraph">
<area shape="rect" title=" " alt="" coords="620,13,729,40"/>
<area shape="rect" href="class_subtitle.html#a337079ce5924d01b6b7aaca29632b9d9" title="加载字幕" alt="" coords="431,13,572,40"/>
<area shape="poly" title=" " alt="" coords="605,29,572,29,572,24,605,24"/>
<area shape="rect" href="class_application.html#a91f6580aea135fa673c03781a2b8497d" title="加载外挂字幕" alt="" coords="211,5,383,48"/>
<area shape="poly" title=" " alt="" coords="416,29,384,29,384,24,416,24"/>
<area shape="rect" href="class_application.html#aae53f3dcf432cfc5c17ebab6fd7d614c" title="创建主窗口" alt="" coords="5,13,163,40"/>
<area shape="poly" title=" " alt="" coords="195,29,163,29,163,24,195,24"/>
</map>
</div>

</div>
</div>
<a id="aa0eb9659d717174434d6c69bb0be089b" name="aa0eb9659d717174434d6c69bb0be089b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0eb9659d717174434d6c69bb0be089b">&#9670;&#160;</a></span>mpv_command_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int mpv_command_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>reply_userdata</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as mpv_command, but run the command asynchronously.</p>
<p>Commands are executed asynchronously. You will receive a MPV_EVENT_COMMAND_REPLY event. This event will also have an error code set if running the command failed. For commands that return data, the data is put into <a class="el" href="structmpv__event__command.html#a0f3ec63d1a48afa8beb9551dda3aadfc">mpv_event_command.result</a>.</p>
<p>The only case when you do not receive an event is when the function call itself fails. This happens only if parsing the command itself (or otherwise validating it) fails, i.e. the return code of the API call is not 0 or positive.</p>
<p>Safe to be called from mpv render API threads.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">reply_userdata</td><td>the value <a class="el" href="structmpv__event.html#a7d12090940e6604658948b7ef1e58ad2">mpv_event.reply_userdata</a> of the reply will be set to (see section about asynchronous calls) </td></tr>
    <tr><td class="paramname">args</td><td>NULL-terminated list of strings (see <a class="el" href="#aa44c1102744f5fa60fec80747fc9b856">mpv_command()</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>error code (if parsing or queuing the command fails) </dd></dl>

</div>
</div>
<a id="abf02e02b212a8b588ba8723643e8ebe9" name="abf02e02b212a8b588ba8723643e8ebe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf02e02b212a8b588ba8723643e8ebe9">&#9670;&#160;</a></span>mpv_command_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int mpv_command_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmpv__node.html">mpv_node</a> *</td>          <td class="paramname"><span class="paramname"><em>args</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmpv__node.html">mpv_node</a> *</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="#aa44c1102744f5fa60fec80747fc9b856">mpv_command()</a>, but allows passing structured data in any format. In particular, calling <a class="el" href="#aa44c1102744f5fa60fec80747fc9b856">mpv_command()</a> is exactly like calling <a class="el" href="#abf02e02b212a8b588ba8723643e8ebe9">mpv_command_node()</a> with the format set to MPV_FORMAT_NODE_ARRAY, and every arg passed in order as MPV_FORMAT_STRING.</p>
<p>Does not use OSD and string expansion by default.</p>
<p>The args argument can have one of the following formats:</p>
<p>MPV_FORMAT_NODE_ARRAY: Positional arguments. Each entry is an argument using an arbitrary format (the format must be compatible to the used command). Usually, the first item is the command name (as MPV_FORMAT_STRING). The order of arguments is as documented in each command description.</p>
<p>MPV_FORMAT_NODE_MAP: Named arguments. This requires at least an entry with the key "name" to be present, which must be a string, and contains the command name. The special entry "_flags" is optional, and if present, must be an array of strings, each being a command prefix to apply. All other entries are interpreted as arguments. They must use the argument names as documented in each command description. Some commands do not support named arguments at all, and must use MPV_FORMAT_NODE_ARRAY.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td><a class="el" href="structmpv__node.html">mpv_node</a> with format set to one of the values documented above (see there for details) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Optional, pass NULL if unused. If not NULL, and if the function succeeds, this is set to command-specific return data. You must call <a class="el" href="#a4dc4983d9482000f58cd14ee66cdf8ba">mpv_free_node_contents()</a> to free it (again, only if the command actually succeeds). Not many commands actually use this at all. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>error code (the result parameter is not set on error) </dd></dl>

</div>
</div>
<a id="a3b980e553adb8231b396555c6c8c8490" name="a3b980e553adb8231b396555c6c8c8490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b980e553adb8231b396555c6c8c8490">&#9670;&#160;</a></span>mpv_command_node_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int mpv_command_node_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>reply_userdata</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmpv__node.html">mpv_node</a> *</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="#abf02e02b212a8b588ba8723643e8ebe9">mpv_command_node()</a>, but run it asynchronously. Basically, this function is to <a class="el" href="#abf02e02b212a8b588ba8723643e8ebe9">mpv_command_node()</a> what <a class="el" href="#aa0eb9659d717174434d6c69bb0be089b">mpv_command_async()</a> is to <a class="el" href="#aa44c1102744f5fa60fec80747fc9b856">mpv_command()</a>.</p>
<p>See <a class="el" href="#aa0eb9659d717174434d6c69bb0be089b">mpv_command_async()</a> for details.</p>
<p>Safe to be called from mpv render API threads.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">reply_userdata</td><td>the value <a class="el" href="structmpv__event.html#a7d12090940e6604658948b7ef1e58ad2">mpv_event.reply_userdata</a> of the reply will be set to (see section about asynchronous calls) </td></tr>
    <tr><td class="paramname">args</td><td>as in <a class="el" href="#abf02e02b212a8b588ba8723643e8ebe9">mpv_command_node()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>error code (if parsing or queuing the command fails) </dd></dl>

</div>
</div>
<a id="a823905244ca283d829e9e4e1c504347f" name="a823905244ca283d829e9e4e1c504347f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a823905244ca283d829e9e4e1c504347f">&#9670;&#160;</a></span>mpv_command_ret()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int mpv_command_ret </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **</td>          <td class="paramname"><span class="paramname"><em>args</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmpv__node.html">mpv_node</a> *</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is essentially identical to <a class="el" href="#aa44c1102744f5fa60fec80747fc9b856">mpv_command()</a> but it also returns a result.</p>
<p>Does not use OSD and string expansion by default.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>NULL-terminated list of strings. Usually, the first item is the command, and the following items are arguments. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Optional, pass NULL if unused. If not NULL, and if the function succeeds, this is set to command-specific return data. You must call <a class="el" href="#a4dc4983d9482000f58cd14ee66cdf8ba">mpv_free_node_contents()</a> to free it (again, only if the command actually succeeds). Not many commands actually use this at all. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>error code (the result parameter is not set on error) </dd></dl>

</div>
</div>
<a id="aeb8e995b0d83679a630ba4100a3b9ba9" name="aeb8e995b0d83679a630ba4100a3b9ba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb8e995b0d83679a630ba4100a3b9ba9">&#9670;&#160;</a></span>mpv_command_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int mpv_command_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as mpv_command, but use input.conf parsing for splitting arguments. This is slightly simpler, but also more error prone, since arguments may need quoting/escaping.</p>
<p>This also has OSD and string expansion enabled by default. </p>

</div>
</div>
<a id="acabb8d28abfb2614024eaa58a4de36e8" name="acabb8d28abfb2614024eaa58a4de36e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acabb8d28abfb2614024eaa58a4de36e8">&#9670;&#160;</a></span>mpv_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> <a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> * mpv_create </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new mpv instance and an associated client API handle to control the mpv instance. This instance is in a pre-initialized state, and needs to be initialized to be actually used with most other API functions.</p>
<p>Some API functions will return MPV_ERROR_UNINITIALIZED in the uninitialized state. You can call <a class="el" href="#a95b9322b70a70cc09f8204d689df97a3">mpv_set_property()</a> (or <a class="el" href="#a292257755e6b358b045254ef1e4534d8">mpv_set_property_string()</a> and other variants, and before mpv 0.21.0 <a class="el" href="#a2eb89863e899876b11de5bf7c6b78912">mpv_set_option()</a> etc.) to set initial options. After this, call <a class="el" href="#a760868c77375524a884ca11917e9fe8b">mpv_initialize()</a> to start the player, and then use e.g. <a class="el" href="#aa44c1102744f5fa60fec80747fc9b856">mpv_command()</a> to start playback of a file.</p>
<p>The point of separating handle creation and actual initialization is that you can configure things which can't be changed during runtime.</p>
<p>Unlike the command line player, this will have initial settings suitable for embedding in applications. The following settings are different:</p><ul>
<li>stdin/stdout/stderr and the terminal will never be accessed. This is equivalent to setting the &ndash;no-terminal option. (Technically, this also suppresses C signal handling.)</li>
<li>No config files will be loaded. This is roughly equivalent to using &ndash;config=no. Since mpv 1.15, you can actually re-enable this option, which will make mpv load config files during <a class="el" href="#a760868c77375524a884ca11917e9fe8b">mpv_initialize()</a>. If you do this, you are strongly encouraged to set the "config-dir" option too. (Otherwise it will load the mpv command line player's config.) For example: mpv_set_option_string(mpv, "config-dir", "/my/path"); // set config root mpv_set_option_string(mpv, "config", "yes"); // enable config loading (call <a class="el" href="#a760868c77375524a884ca11917e9fe8b">mpv_initialize()</a> <em>after</em> this)</li>
<li>Idle mode is enabled, which means the playback core will enter idle mode if there are no more files to play on the internal playlist, instead of exiting. This is equivalent to the &ndash;idle option.</li>
<li>Disable parts of input handling.</li>
<li>Most of the different settings can be viewed with the command line player by running "mpv --show-profile=mpv".</li>
</ul>
<p>All this assumes that API users want a mpv instance that is strictly isolated from the command line player's configuration, user settings, and so on. You can re-enable disabled features by setting the appropriate options.</p>
<p>The mpv command line parser is not available through this API, but you can set individual options with <a class="el" href="#a95b9322b70a70cc09f8204d689df97a3">mpv_set_property()</a>. Files for playback must be loaded with <a class="el" href="#aa44c1102744f5fa60fec80747fc9b856">mpv_command()</a> or others.</p>
<p>Note that you should avoid doing concurrent accesses on the uninitialized client handle. (Whether concurrent access is definitely allowed or not has yet to be decided.)</p>
<dl class="section return"><dt>返回</dt><dd>a new mpv client API handle. Returns NULL on error. Currently, this can happen in the following situations:<ul>
<li>out of memory</li>
<li>LC_NUMERIC is not set to "C" (see general remarks) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a645dba46c9ab76eefe2cd9d3343dbf49" name="a645dba46c9ab76eefe2cd9d3343dbf49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a645dba46c9ab76eefe2cd9d3343dbf49">&#9670;&#160;</a></span>mpv_create_client()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> <a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> * mpv_create_client </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new client handle connected to the same player core as ctx. This context has its own event queue, its own <a class="el" href="#a71c37df225044f5f8db5cb0c048fa902">mpv_request_event()</a> state, its own <a class="el" href="#a2cd1f2768f461a351a1d8ad345539492">mpv_request_log_messages()</a> state, its own set of observed properties, and its own state for asynchronous operations. Otherwise, everything is shared.</p>
<p>This handle should be destroyed with <a class="el" href="#ae12b97104f3bbe302d96260c33728f07">mpv_destroy()</a> if no longer needed. The core will live as long as there is at least 1 handle referencing it. Any handle can make the core quit, which will result in every handle receiving MPV_EVENT_SHUTDOWN.</p>
<p>This function can not be called before the main handle was initialized with <a class="el" href="#a760868c77375524a884ca11917e9fe8b">mpv_initialize()</a>. The new handle is always initialized, unless ctx=NULL was passed.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>Used to get the reference to the mpv core; handle-specific settings and parameters are not used. If NULL, this function behaves like <a class="el" href="#acabb8d28abfb2614024eaa58a4de36e8">mpv_create()</a> (ignores name). </td></tr>
    <tr><td class="paramname">name</td><td>The client name. This will be returned by <a class="el" href="#a6ed74ba4e80320ee0a9b16cba220ff4d">mpv_client_name()</a>. If the name is already in use, or contains non-alphanumeric characters (other than '_'), the name is modified to fit. If NULL, an arbitrary name is automatically chosen. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>a new handle, or NULL on error </dd></dl>

</div>
</div>
<a id="af6c555fbf54ab016966b4b6213241fe7" name="af6c555fbf54ab016966b4b6213241fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6c555fbf54ab016966b4b6213241fe7">&#9670;&#160;</a></span>mpv_create_weak_client()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> <a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> * mpv_create_weak_client </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the same as <a class="el" href="#a645dba46c9ab76eefe2cd9d3343dbf49">mpv_create_client()</a>, but the created mpv_handle is treated as a weak reference. If all mpv_handles referencing a core are weak references, the core is automatically destroyed. (This still goes through normal uninit of course. Effectively, if the last non-weak mpv_handle is destroyed, then the weak mpv_handles receive MPV_EVENT_SHUTDOWN and are asked to terminate as well.)</p>
<p>Note if you want to use this like refcounting: you have to be aware that <a class="el" href="#a831ff5d62abb8eab842af9ec23f182a6">mpv_terminate_destroy()</a> <em>and</em> <a class="el" href="#ae12b97104f3bbe302d96260c33728f07">mpv_destroy()</a> for the last non-weak mpv_handle will block until all weak mpv_handles are destroyed. </p>

</div>
</div>
<a id="a63578b469f1aa1e4dcf7d0cb201735cc" name="a63578b469f1aa1e4dcf7d0cb201735cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63578b469f1aa1e4dcf7d0cb201735cc">&#9670;&#160;</a></span>mpv_del_property()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int mpv_del_property </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience function to delete a property.</p>
<p>This is equivalent to running the command "del [name]".</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The property name. See input.rst for a list of properties. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>error code </dd></dl>

</div>
</div>
<a id="ae12b97104f3bbe302d96260c33728f07" name="ae12b97104f3bbe302d96260c33728f07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae12b97104f3bbe302d96260c33728f07">&#9670;&#160;</a></span>mpv_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> void mpv_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disconnect and destroy the mpv_handle. ctx will be deallocated with this API call.</p>
<p>If the last mpv_handle is detached, the core player is destroyed. In addition, if there are only weak mpv_handles (such as created by <a class="el" href="#af6c555fbf54ab016966b4b6213241fe7">mpv_create_weak_client()</a> or internal scripts), these mpv_handles will be sent MPV_EVENT_SHUTDOWN. This function may block until these clients have responded to the shutdown event, and the core is finally destroyed. </p>

</div>
</div>
<a id="a71c1f3705e6918d81286fb55ac6c5294" name="a71c1f3705e6918d81286fb55ac6c5294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71c1f3705e6918d81286fb55ac6c5294">&#9670;&#160;</a></span>mpv_error_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> const char * mpv_error_string </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>error</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a string describing the error. For unknown errors, the string "unknown error" is returned.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>error number, see enum mpv_error </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A static string describing the error. The string is completely static, i.e. doesn't need to be deallocated, and is valid forever. </dd></dl>

</div>
</div>
<a id="a8ca6494a0cc3799cf13f97ed9927073f" name="a8ca6494a0cc3799cf13f97ed9927073f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ca6494a0cc3799cf13f97ed9927073f">&#9670;&#160;</a></span>mpv_event_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> const char * mpv_event_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aab05e07858ef82e9c08f7e3727f5d40c">mpv_event_id</a></td>          <td class="paramname"><span class="paramname"><em>event</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a string describing the event. For unknown events, NULL is returned.</p>
<p>Note that all events actually returned by the API will also yield a non-NULL string with this function.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>event ID, see see enum mpv_event_id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A static string giving a short symbolic name of the event. It consists of lower-case alphanumeric characters and can include "-" characters. This string is suitable for use in e.g. scripting interfaces. The string is completely static, i.e. doesn't need to be deallocated, and is valid forever. </dd></dl>

</div>
</div>
<a id="a59a4b06230913cabddf6bfbfe701f110" name="a59a4b06230913cabddf6bfbfe701f110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59a4b06230913cabddf6bfbfe701f110">&#9670;&#160;</a></span>mpv_event_to_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int mpv_event_to_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmpv__node.html">mpv_node</a> *</td>          <td class="paramname"><span class="paramname"><em>dst</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmpv__event.html">mpv_event</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert the given src event to a <a class="el" href="structmpv__node.html">mpv_node</a>, and set <em>dst to the result. *dst is set to a MPV_FORMAT_NODE_MAP, with fields for corresponding <a class="el" href="structmpv__event.html">mpv_event</a> and <a class="el" href="structmpv__event.html#ad1c9cea2929c5cffe5b90d091a7209f6">mpv_event.data</a>/mpv_event_</em> fields.</p>
<p>The exact details are not completely documented out of laziness. A start is located in the "Events" section of the manpage.</p>
<p>*dst may point to newly allocated memory, or pointers in <a class="el" href="structmpv__event.html">mpv_event</a>. You must copy the entire <a class="el" href="structmpv__node.html">mpv_node</a> if you want to reference it after <a class="el" href="structmpv__event.html">mpv_event</a> becomes invalid (such as making a new <a class="el" href="#a14715be5aab817bb71770f711b64102a">mpv_wait_event()</a> call, or destroying the mpv_handle from which it was returned). Call <a class="el" href="#a4dc4983d9482000f58cd14ee66cdf8ba">mpv_free_node_contents()</a> to free any memory allocations made by this API function.</p>
<p>Safe to be called from mpv render API threads.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>Target. This is not read and fully overwritten. Must be released with <a class="el" href="#a4dc4983d9482000f58cd14ee66cdf8ba">mpv_free_node_contents()</a>. Do not write to pointers returned by it. (On error, this may be left as an empty node.) </td></tr>
    <tr><td class="paramname">src</td><td>The source event. Not modified (it's not const due to the author's prejudice of the C version of const). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>error code (MPV_ERROR_NOMEM only, if at all) </dd></dl>

</div>
</div>
<a id="a585d349a4005c7eaf01f28f59eb9e4ea" name="a585d349a4005c7eaf01f28f59eb9e4ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a585d349a4005c7eaf01f28f59eb9e4ea">&#9670;&#160;</a></span>mpv_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> void mpv_free </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>General function to deallocate memory returned by some of the API functions. Call this only if it's explicitly documented as allowed. Calling this on mpv memory not owned by the caller will lead to undefined behavior.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A valid pointer returned by the API, or NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4dc4983d9482000f58cd14ee66cdf8ba" name="a4dc4983d9482000f58cd14ee66cdf8ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dc4983d9482000f58cd14ee66cdf8ba">&#9670;&#160;</a></span>mpv_free_node_contents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> void mpv_free_node_contents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmpv__node.html">mpv_node</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees any data referenced by the node. It doesn't free the node itself. Call this only if the mpv client API set the node. If you constructed the node yourself (manually), you have to free it yourself.</p>
<p>If node-&gt;format is MPV_FORMAT_NONE, this call does nothing. Likewise, if the client API sets a node with this format, this function doesn't need to be called. (This is just a clarification that there's no danger of anything strange happening in these cases.) </p>
<div class="dynheader">
这是这个函数的调用关系图:</div>
<div class="dyncontent">
<div class="center"><img src="client_8h_a4dc4983d9482000f58cd14ee66cdf8ba_icgraph.png" border="0" usemap="#aclient_8h_a4dc4983d9482000f58cd14ee66cdf8ba_icgraph" alt=""/></div>
<map name="aclient_8h_a4dc4983d9482000f58cd14ee66cdf8ba_icgraph" id="aclient_8h_a4dc4983d9482000f58cd14ee66cdf8ba_icgraph">
<area shape="rect" title=" " alt="" coords="656,13,821,40"/>
<area shape="rect" href="class_subtitle.html#ad0b734f49236b5c18825882af3c3a7ec" title="获取字幕列表" alt="" coords="452,13,608,40"/>
<area shape="poly" title=" " alt="" coords="641,29,609,29,609,24,641,24"/>
<area shape="rect" href="class_application.html#a2489c149418cd3f3aa5add22a47ca115" title="字幕列表" alt="" coords="211,5,404,48"/>
<area shape="poly" title=" " alt="" coords="437,29,405,29,405,24,437,24"/>
<area shape="rect" href="class_application.html#aae53f3dcf432cfc5c17ebab6fd7d614c" title="创建主窗口" alt="" coords="5,13,163,40"/>
<area shape="poly" title=" " alt="" coords="195,29,163,29,163,24,195,24"/>
</map>
</div>

</div>
</div>
<a id="aeca58b3b9eadb3cd70953d9cba238958" name="aeca58b3b9eadb3cd70953d9cba238958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeca58b3b9eadb3cd70953d9cba238958">&#9670;&#160;</a></span>mpv_get_property()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int mpv_get_property </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a8de0a5cfaeed2adfe0c344df68ba292f">mpv_format</a></td>          <td class="paramname"><span class="paramname"><em>format</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the value of the given property.</p>
<p>If the format doesn't match with the internal format of the property, access usually will fail with MPV_ERROR_PROPERTY_FORMAT. In some cases, the data is automatically converted and access succeeds. For example, MPV_FORMAT_INT64 is always converted to MPV_FORMAT_DOUBLE, and access using MPV_FORMAT_STRING usually invokes a string formatter.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">name</td><td>The property name. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">format</td><td>see enum mpv_format. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Pointer to the variable holding the option value. On success, the variable will be set to a copy of the option value. For formats that require dynamic memory allocation, you can free the value with <a class="el" href="#a585d349a4005c7eaf01f28f59eb9e4ea">mpv_free()</a> (strings) or <a class="el" href="#a4dc4983d9482000f58cd14ee66cdf8ba">mpv_free_node_contents()</a> (MPV_FORMAT_NODE). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>error code </dd></dl>
<div class="dynheader">
这是这个函数的调用关系图:</div>
<div class="dyncontent">
<div class="center"><img src="client_8h_aeca58b3b9eadb3cd70953d9cba238958_icgraph.png" border="0" usemap="#aclient_8h_aeca58b3b9eadb3cd70953d9cba238958_icgraph" alt=""/></div>
<map name="aclient_8h_aeca58b3b9eadb3cd70953d9cba238958_icgraph" id="aclient_8h_aeca58b3b9eadb3cd70953d9cba238958_icgraph">
<area shape="rect" title=" " alt="" coords="656,72,780,99"/>
<area shape="rect" href="class_subtitle.html#ad0b734f49236b5c18825882af3c3a7ec" title="获取字幕列表" alt="" coords="452,13,608,40"/>
<area shape="poly" title=" " alt="" coords="658,69,574,43,576,38,659,64"/>
<area shape="rect" href="class_controller.html#a52be8e1378e797cca9dfd8be9c225b90" title="应对在线视频在开始播放时，可能并未完全加载，其总时长未知需要缓冲后更新的情况" alt="" coords="452,64,608,107"/>
<area shape="poly" title=" " alt="" coords="641,88,608,88,608,83,641,83"/>
<area shape="rect" href="class_controller.html#ae97547b171bf1c7a8bb20250200775c0" title="播放时更新滑块位置" alt="" coords="452,131,608,173"/>
<area shape="poly" title=" " alt="" coords="665,107,593,133,592,128,663,102"/>
<area shape="rect" href="class_application.html#a2489c149418cd3f3aa5add22a47ca115" title="字幕列表" alt="" coords="211,5,404,48"/>
<area shape="poly" title=" " alt="" coords="437,29,405,29,405,24,437,24"/>
<area shape="rect" href="class_application.html#aae53f3dcf432cfc5c17ebab6fd7d614c" title="创建主窗口" alt="" coords="5,13,163,40"/>
<area shape="poly" title=" " alt="" coords="195,29,163,29,163,24,195,24"/>
<area shape="rect" href="class_controller.html#a9de3b2de7339605b0cdf56392da6a1d1" title=" " alt="" coords="238,105,377,132"/>
<area shape="poly" title=" " alt="" coords="437,102,378,111,377,106,436,97"/>
<area shape="poly" title=" " alt="" coords="436,141,377,132,378,126,437,135"/>
</map>
</div>

</div>
</div>
<a id="a08d2ef781815c9eea2614d5267c7cf6e" name="a08d2ef781815c9eea2614d5267c7cf6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08d2ef781815c9eea2614d5267c7cf6e">&#9670;&#160;</a></span>mpv_get_property_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int mpv_get_property_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>reply_userdata</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a8de0a5cfaeed2adfe0c344df68ba292f">mpv_format</a></td>          <td class="paramname"><span class="paramname"><em>format</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a property asynchronously. You will receive the result of the operation as well as the property data with the MPV_EVENT_GET_PROPERTY_REPLY event. You should check the <a class="el" href="structmpv__event.html#af671002ddcb1bf25e23230a81cfaa498">mpv_event.error</a> field on the reply event.</p>
<p>Safe to be called from mpv render API threads.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">reply_userdata</td><td>see section about asynchronous calls </td></tr>
    <tr><td class="paramname">name</td><td>The property name. </td></tr>
    <tr><td class="paramname">format</td><td>see enum mpv_format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>error code if sending the request failed </dd></dl>

</div>
</div>
<a id="a87f5a5bf7777b723a3ffec94f6264525" name="a87f5a5bf7777b723a3ffec94f6264525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87f5a5bf7777b723a3ffec94f6264525">&#9670;&#160;</a></span>mpv_get_property_osd_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> char * mpv_get_property_osd_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the property as "OSD" formatted string. This is the same as mpv_get_property_string, but using MPV_FORMAT_OSD_STRING.</p>
<dl class="section return"><dt>返回</dt><dd>Property value, or NULL if the property can't be retrieved. Free the string with <a class="el" href="#a585d349a4005c7eaf01f28f59eb9e4ea">mpv_free()</a>. </dd></dl>

</div>
</div>
<a id="a83f459695d01260a86ca746e1b50e39a" name="a83f459695d01260a86ca746e1b50e39a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83f459695d01260a86ca746e1b50e39a">&#9670;&#160;</a></span>mpv_get_property_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> char * mpv_get_property_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a8de0a5cfaeed2adfe0c344df68ba292f">mpv_format</a></td>          <td class="paramname"><span class="paramname"><em>format</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>pString</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the value of the property with the given name as string. This is equivalent to <a class="el" href="#aeca58b3b9eadb3cd70953d9cba238958">mpv_get_property()</a> with MPV_FORMAT_STRING.</p>
<p>See MPV_FORMAT_STRING for character encoding issues.</p>
<p>On error, NULL is returned. Use <a class="el" href="#aeca58b3b9eadb3cd70953d9cba238958">mpv_get_property()</a> if you want fine-grained error reporting.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The property name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>Property value, or NULL if the property can't be retrieved. Free the string with <a class="el" href="#a585d349a4005c7eaf01f28f59eb9e4ea">mpv_free()</a>. </dd></dl>

</div>
</div>
<a id="adf4cf360b8f86e7fdbabced592b93411" name="adf4cf360b8f86e7fdbabced592b93411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf4cf360b8f86e7fdbabced592b93411">&#9670;&#160;</a></span>mpv_get_time_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int64_t mpv_get_time_ns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the internal time in nanoseconds. This has an arbitrary start offset, but will never wrap or go backwards.</p>
<p>Note that this is always the real time, and doesn't necessarily have to do with playback time. For example, playback could go faster or slower due to playback speed, or due to playback being paused. Use the "time-pos" property instead to get the playback status.</p>
<p>Unlike other mpv APIs, this can be called at absolutely any time (even within wakeup callbacks), as long as the context is valid.</p>
<p>Safe to be called from mpv render API threads. </p>

</div>
</div>
<a id="a855c8887b117fa6fed3e89b3c1d98c90" name="a855c8887b117fa6fed3e89b3c1d98c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a855c8887b117fa6fed3e89b3c1d98c90">&#9670;&#160;</a></span>mpv_get_time_us()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int64_t mpv_get_time_us </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as mpv_get_time_ns but in microseconds. </p>

</div>
</div>
<a id="aaeb5fcef1a43e3d3462fa138cff39339" name="aaeb5fcef1a43e3d3462fa138cff39339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeb5fcef1a43e3d3462fa138cff39339">&#9670;&#160;</a></span>mpv_get_wakeup_pipe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int mpv_get_wakeup_pipe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a UNIX file descriptor referring to the read end of a pipe. This pipe can be used to wake up a poll() based processing loop. The purpose of this function is very similar to <a class="el" href="#a54b24fa9076b9c0ca5f988709d20e736">mpv_set_wakeup_callback()</a>, and provides a primitive mechanism to handle coordinating a foreign event loop and the mpv event loop. The pipe is non-blocking. It's closed when the mpv_handle is destroyed. This function always returns the same value (on success).</p>
<p>This is in fact implemented using the same underlying code as for <a class="el" href="#a54b24fa9076b9c0ca5f988709d20e736">mpv_set_wakeup_callback()</a> (though they don't conflict), and it is as if each callback invocation writes a single 0 byte to the pipe. When the pipe becomes readable, the code calling poll() (or select()) on the pipe should read all contents of the pipe and then call mpv_wait_event(c, 0) until no new events are returned. The pipe contents do not matter and can just be discarded. There is not necessarily one byte per readable event in the pipe. For example, the pipes are non-blocking, and mpv won't block if the pipe is full. Pipes are normally limited to 4096 bytes, so if there are more than 4096 events, the number of readable bytes can not equal the number of events queued. Also, it's possible that mpv does not write to the pipe once it's guaranteed that the client was already signaled. See the example below how to do it correctly.</p>
<p>Example:</p>
<p>int pipefd = mpv_get_wakeup_pipe(mpv); if (pipefd &lt; 0) error(); while (1) { struct pollfd pfds[1] = { { .fd = pipefd, .events = POLLIN }, }; // Wait until there are possibly new mpv events. poll(pfds, 1, -1); if (pfds[0].revents &amp; POLLIN) { // Empty the pipe. Doing this before calling <a class="el" href="#a14715be5aab817bb71770f711b64102a">mpv_wait_event()</a> // ensures that no wakeups are missed. It's not so important to // make sure the pipe is really empty (it will just cause some // additional wakeups in unlikely corner cases). char unused[256]; read(pipefd, unused, sizeof(unused)); while (1) { <a class="el" href="structmpv__event.html">mpv_event</a> *ev = mpv_wait_event(mpv, 0); // If MPV_EVENT_NONE is received, the event queue is empty. if (ev-&gt;event_id == MPV_EVENT_NONE) break; // Process the event. ... } } }</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">弃用</a></b></dt><dd>this function will be removed in the future. If you need this functionality, use <a class="el" href="#a54b24fa9076b9c0ca5f988709d20e736">mpv_set_wakeup_callback()</a>, create a pipe manually, and call write() on your pipe in the callback.</dd></dl>
<dl class="section return"><dt>返回</dt><dd>A UNIX FD of the read end of the wakeup pipe, or -1 on error. On MS Windows/MinGW, this will always return -1. </dd></dl>

</div>
</div>
<a id="af96a59b780ea3a0d7cf01c71116e136f" name="af96a59b780ea3a0d7cf01c71116e136f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af96a59b780ea3a0d7cf01c71116e136f">&#9670;&#160;</a></span>mpv_hook_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int mpv_hook_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>reply_userdata</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>priority</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A hook is like a synchronous event that blocks the player. You register a hook handler with this function. You will get an event, which you need to handle, and once things are ready, you can let the player continue with <a class="el" href="#a6dd7bc86098f32e660bda2c14ca2eda6">mpv_hook_continue()</a>.</p>
<p>Currently, hooks can't be removed explicitly. But they will be implicitly removed if the mpv_handle it was registered with is destroyed. This also continues the hook if it was being handled by the destroyed mpv_handle (but this should be avoided, as it might mess up order of hook execution).</p>
<p>Hook handlers are ordered globally by priority and order of registration. Handlers for the same hook with same priority are invoked in order of registration (the handler registered first is run first). Handlers with lower priority are run first (which seems backward).</p>
<p>See the "Hooks" section in the manpage to see which hooks are currently defined.</p>
<p>Some hooks might be reentrant (so you get multiple MPV_EVENT_HOOK for the same hook). If this can happen for a specific hook type, it will be explicitly documented in the manpage.</p>
<p>Only the mpv_handle on which this was called will receive the hook events, or can "continue" them.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">reply_userdata</td><td>This will be used for the <a class="el" href="structmpv__event.html#a7d12090940e6604658948b7ef1e58ad2">mpv_event.reply_userdata</a> field for the received MPV_EVENT_HOOK events. If you have no use for this, pass 0. </td></tr>
    <tr><td class="paramname">name</td><td>The hook name. This should be one of the documented names. But if the name is unknown, the hook event will simply be never raised. </td></tr>
    <tr><td class="paramname">priority</td><td>See remarks above. Use 0 as a neutral default. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>error code (usually fails only on OOM) </dd></dl>

</div>
</div>
<a id="a6dd7bc86098f32e660bda2c14ca2eda6" name="a6dd7bc86098f32e660bda2c14ca2eda6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dd7bc86098f32e660bda2c14ca2eda6">&#9670;&#160;</a></span>mpv_hook_continue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int mpv_hook_continue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>id</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Respond to a MPV_EVENT_HOOK event. You must call this after you have handled the event. There is no way to "cancel" or "stop" the hook.</p>
<p>Calling this will will typically unblock the player for whatever the hook is responsible for (e.g. for the "on_load" hook it lets it continue playback).</p>
<p>It is explicitly undefined behavior to call this more than once for each MPV_EVENT_HOOK, to pass an incorrect ID, or to call this on a mpv_handle different from the one that registered the handler and received the event.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>This must be the value of the <a class="el" href="structmpv__event__hook.html#a6bdd0eda748608398c5bf7f74d17843a">mpv_event_hook.id</a> field for the corresponding MPV_EVENT_HOOK. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>error code </dd></dl>

</div>
</div>
<a id="a760868c77375524a884ca11917e9fe8b" name="a760868c77375524a884ca11917e9fe8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a760868c77375524a884ca11917e9fe8b">&#9670;&#160;</a></span>mpv_initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int mpv_initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize an uninitialized mpv instance. If the mpv instance is already running, an error is returned.</p>
<p>This function needs to be called to make full use of the client API if the client API handle was created with <a class="el" href="#acabb8d28abfb2614024eaa58a4de36e8">mpv_create()</a>.</p>
<p>Only the following options are required to be set <em>before</em> <a class="el" href="#a760868c77375524a884ca11917e9fe8b">mpv_initialize()</a>:</p><ul>
<li>options which are only read at initialization time:<ul>
<li>config</li>
<li>config-dir</li>
<li>input-conf</li>
<li>load-scripts</li>
<li>script</li>
<li>player-operation-mode</li>
<li>input-app-events (OSX)</li>
</ul>
</li>
<li>all encoding mode options</li>
</ul>
<dl class="section return"><dt>返回</dt><dd>error code </dd></dl>
<div class="dynheader">
这是这个函数的调用关系图:</div>
<div class="dyncontent">
<div class="center"><img src="client_8h_a760868c77375524a884ca11917e9fe8b_icgraph.png" border="0" usemap="#aclient_8h_a760868c77375524a884ca11917e9fe8b_icgraph" alt=""/></div>
<map name="aclient_8h_a760868c77375524a884ca11917e9fe8b_icgraph" id="aclient_8h_a760868c77375524a884ca11917e9fe8b_icgraph">
<area shape="rect" title=" " alt="" coords="193,5,291,32"/>
<area shape="rect" href="class_controller.html#a9de3b2de7339605b0cdf56392da6a1d1" title=" " alt="" coords="5,5,145,32"/>
<area shape="poly" title=" " alt="" coords="177,21,145,21,145,16,177,16"/>
</map>
</div>

</div>
</div>
<a id="a934a427f05ac9e93b78168ea0eee5c24" name="a934a427f05ac9e93b78168ea0eee5c24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a934a427f05ac9e93b78168ea0eee5c24">&#9670;&#160;</a></span>mpv_load_config_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int mpv_load_config_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load a config file. This loads and parses the file, and sets every entry in the config file's default section as if <a class="el" href="#ada06ff1f821683e60b531d96ccc69264">mpv_set_option_string()</a> is called.</p>
<p>The filename should be an absolute path. If it isn't, the actual path used is unspecified. (Note: an absolute path starts with '/' on UNIX.) If the file wasn't found, MPV_ERROR_INVALID_PARAMETER is returned.</p>
<p>If a fatal error happens when parsing a config file, MPV_ERROR_OPTION_ERROR is returned. Errors when setting options as well as other types or errors are ignored (even if options do not exist). You can still try to capture the resulting error messages with <a class="el" href="#a2cd1f2768f461a351a1d8ad345539492">mpv_request_log_messages()</a>. Note that it's possible that some options were successfully set even if any of these errors happen.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>absolute path to the config file on the local filesystem </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>error code </dd></dl>

</div>
</div>
<a id="af3d2b287c0f994fb3649c1a1bf85591e" name="af3d2b287c0f994fb3649c1a1bf85591e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3d2b287c0f994fb3649c1a1bf85591e">&#9670;&#160;</a></span>mpv_observe_property()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int mpv_observe_property </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *</td>          <td class="paramname"><span class="paramname"><em>mpv</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>reply_userdata</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a8de0a5cfaeed2adfe0c344df68ba292f">mpv_format</a></td>          <td class="paramname"><span class="paramname"><em>format</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a notification whenever the given property changes. You will receive updates as MPV_EVENT_PROPERTY_CHANGE. Note that this is not very precise: for some properties, it may not send updates even if the property changed. This depends on the property, and it's a valid feature request to ask for better update handling of a specific property. (For some properties, like <code>clock</code>, which shows the wall clock, this mechanism doesn't make too much sense anyway.)</p>
<p>Property changes are coalesced: the change events are returned only once the event queue becomes empty (e.g. <a class="el" href="#a14715be5aab817bb71770f711b64102a">mpv_wait_event()</a> would block or return MPV_EVENT_NONE), and then only one event per changed property is returned.</p>
<p>You always get an initial change notification. This is meant to initialize the user's state to the current value of the property.</p>
<p>Normally, change events are sent only if the property value changes according to the requested format. <a class="el" href="structmpv__event__property.html">mpv_event_property</a> will contain the property value as data member.</p>
<p>Warning: if a property is unavailable or retrieving it caused an error, MPV_FORMAT_NONE will be set in <a class="el" href="structmpv__event__property.html">mpv_event_property</a>, even if the format parameter was set to a different value. In this case, the <a class="el" href="structmpv__event__property.html#a2b277bbb2981ea246cfb96fa6e7b97e0">mpv_event_property.data</a> field is invalid.</p>
<p>If the property is observed with the format parameter set to MPV_FORMAT_NONE, you get low-level notifications whether the property <em>may</em> have changed, and the data member in <a class="el" href="structmpv__event__property.html">mpv_event_property</a> will be unset. With this mode, you will have to determine yourself whether the property really changed. On the other hand, this mechanism can be faster and uses less resources.</p>
<p>Observing a property that doesn't exist is allowed. (Although it may still cause some sporadic change events.)</p>
<p>Keep in mind that you will get change notifications even if you change a property yourself. Try to avoid endless feedback loops, which could happen if you react to the change notifications triggered by your own change.</p>
<p>Only the mpv_handle on which this was called will receive the property change events, or can unobserve them.</p>
<p>Safe to be called from mpv render API threads.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">reply_userdata</td><td>This will be used for the <a class="el" href="structmpv__event.html#a7d12090940e6604658948b7ef1e58ad2">mpv_event.reply_userdata</a> field for the received MPV_EVENT_PROPERTY_CHANGE events. (Also see section about asynchronous calls, although this function is somewhat different from actual asynchronous calls.) If you have no use for this, pass 0. Also see <a class="el" href="#a8cc02c1e7054f92c7e7502d88336d57e">mpv_unobserve_property()</a>. </td></tr>
    <tr><td class="paramname">name</td><td>The property name. </td></tr>
    <tr><td class="paramname">format</td><td>see enum mpv_format. Can be MPV_FORMAT_NONE to omit values from the change events. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>error code (usually fails only on OOM or unsupported format) </dd></dl>

</div>
</div>
<a id="a71c37df225044f5f8db5cb0c048fa902" name="a71c37df225044f5f8db5cb0c048fa902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71c37df225044f5f8db5cb0c048fa902">&#9670;&#160;</a></span>mpv_request_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int mpv_request_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aab05e07858ef82e9c08f7e3727f5d40c">mpv_event_id</a></td>          <td class="paramname"><span class="paramname"><em>event</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>enable</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable or disable the given event.</p>
<p>Some events are enabled by default. Some events can't be disabled.</p>
<p>(Informational note: currently, all events are enabled by default, except MPV_EVENT_TICK.)</p>
<p>Safe to be called from mpv render API threads.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>See enum mpv_event_id. </td></tr>
    <tr><td class="paramname">enable</td><td>1 to enable receiving this event, 0 to disable it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>error code </dd></dl>

</div>
</div>
<a id="a2cd1f2768f461a351a1d8ad345539492" name="a2cd1f2768f461a351a1d8ad345539492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cd1f2768f461a351a1d8ad345539492">&#9670;&#160;</a></span>mpv_request_log_messages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int mpv_request_log_messages </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>min_level</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable or disable receiving of log messages. These are the messages the command line player prints to the terminal. This call sets the minimum required log level for a message to be received with MPV_EVENT_LOG_MESSAGE.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">min_level</td><td>Minimal log level as string. Valid log levels: no fatal error warn info v debug trace The value "no" disables all messages. This is the default. An exception is the value "terminal-default", which uses the log level as set by the "--msg-level" option. This works even if the terminal is disabled. (Since API version 1.19.) Also see mpv_log_level. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>error code </dd></dl>

</div>
</div>
<a id="a2eb89863e899876b11de5bf7c6b78912" name="a2eb89863e899876b11de5bf7c6b78912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eb89863e899876b11de5bf7c6b78912">&#9670;&#160;</a></span>mpv_set_option()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int mpv_set_option </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a8de0a5cfaeed2adfe0c344df68ba292f">mpv_format</a></td>          <td class="paramname"><span class="paramname"><em>format</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set an option. Note that you can't normally set options during runtime. It works in uninitialized state (see <a class="el" href="#acabb8d28abfb2614024eaa58a4de36e8">mpv_create()</a>), and in some cases in at runtime.</p>
<p>Using a format other than MPV_FORMAT_NODE is equivalent to constructing a <a class="el" href="structmpv__node.html">mpv_node</a> with the given format and data, and passing the <a class="el" href="structmpv__node.html">mpv_node</a> to this function.</p>
<p>Note: this is semi-deprecated. For most purposes, this is not needed anymore. Starting with mpv version 0.21.0 (version 1.23) most options can be set with <a class="el" href="#a95b9322b70a70cc09f8204d689df97a3">mpv_set_property()</a> (and related functions), and even before <a class="el" href="#a760868c77375524a884ca11917e9fe8b">mpv_initialize()</a>. In some obscure corner cases, using this function to set options might still be required (see "Inconsistencies between options and properties" in the manpage). Once these are resolved, the option setting functions might be fully deprecated.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">name</td><td>Option name. This is the same as on the mpv command line, but without the leading "--". </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">format</td><td>see enum mpv_format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Option value (according to the format). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>error code </dd></dl>

</div>
</div>
<a id="ada06ff1f821683e60b531d96ccc69264" name="ada06ff1f821683e60b531d96ccc69264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada06ff1f821683e60b531d96ccc69264">&#9670;&#160;</a></span>mpv_set_option_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int mpv_set_option_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience function to set an option to a string value. This is like calling <a class="el" href="#a2eb89863e899876b11de5bf7c6b78912">mpv_set_option()</a> with MPV_FORMAT_STRING.</p>
<dl class="section return"><dt>返回</dt><dd>error code </dd></dl>
<div class="dynheader">
这是这个函数的调用关系图:</div>
<div class="dyncontent">
<div class="center"><img src="client_8h_ada06ff1f821683e60b531d96ccc69264_icgraph.png" border="0" usemap="#aclient_8h_ada06ff1f821683e60b531d96ccc69264_icgraph" alt=""/></div>
<map name="aclient_8h_ada06ff1f821683e60b531d96ccc69264_icgraph" id="aclient_8h_ada06ff1f821683e60b531d96ccc69264_icgraph">
<area shape="rect" title=" " alt="" coords="439,31,589,57"/>
<area shape="rect" href="class_controller.html#a9de3b2de7339605b0cdf56392da6a1d1" title=" " alt="" coords="231,5,371,32"/>
<area shape="poly" title=" " alt="" coords="423,36,371,30,371,24,424,31"/>
<area shape="rect" href="class_controller.html#a89d392cb8988e9627901ae62edbf7675" title="将MPV的视频输出绑定到QWidget上" alt="" coords="211,56,391,83"/>
<area shape="poly" title=" " alt="" coords="424,57,392,61,391,56,423,52"/>
<area shape="rect" href="class_application.html#aae53f3dcf432cfc5c17ebab6fd7d614c" title="创建主窗口" alt="" coords="5,56,163,83"/>
<area shape="poly" title=" " alt="" coords="195,72,163,72,163,67,195,67"/>
</map>
</div>

</div>
</div>
<a id="a95b9322b70a70cc09f8204d689df97a3" name="a95b9322b70a70cc09f8204d689df97a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95b9322b70a70cc09f8204d689df97a3">&#9670;&#160;</a></span>mpv_set_property()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int mpv_set_property </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a8de0a5cfaeed2adfe0c344df68ba292f">mpv_format</a></td>          <td class="paramname"><span class="paramname"><em>format</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a property to a given value. Properties are essentially variables which can be queried or set at runtime. For example, writing to the pause property will actually pause or unpause playback.</p>
<p>If the format doesn't match with the internal format of the property, access usually will fail with MPV_ERROR_PROPERTY_FORMAT. In some cases, the data is automatically converted and access succeeds. For example, MPV_FORMAT_INT64 is always converted to MPV_FORMAT_DOUBLE, and access using MPV_FORMAT_STRING usually invokes a string parser. The same happens when calling this function with MPV_FORMAT_NODE: the underlying format may be converted to another type if possible.</p>
<p>Using a format other than MPV_FORMAT_NODE is equivalent to constructing a <a class="el" href="structmpv__node.html">mpv_node</a> with the given format and data, and passing the <a class="el" href="structmpv__node.html">mpv_node</a> to this function. (Before API version 1.21, this was different.)</p>
<p>Note: starting with mpv 0.21.0 (client API version 1.23), this can be used to set options in general. It even can be used before <a class="el" href="#a760868c77375524a884ca11917e9fe8b">mpv_initialize()</a> has been called. If called before <a class="el" href="#a760868c77375524a884ca11917e9fe8b">mpv_initialize()</a>, setting properties not backed by options will result in MPV_ERROR_PROPERTY_UNAVAILABLE. In some cases, properties and options still conflict. In these cases, <a class="el" href="#a95b9322b70a70cc09f8204d689df97a3">mpv_set_property()</a> accesses the options before <a class="el" href="#a760868c77375524a884ca11917e9fe8b">mpv_initialize()</a>, and the properties after <a class="el" href="#a760868c77375524a884ca11917e9fe8b">mpv_initialize()</a>. These conflicts will be removed in mpv 0.23.0. See <a class="el" href="#a2eb89863e899876b11de5bf7c6b78912">mpv_set_option()</a> for further remarks.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">name</td><td>The property name. See input.rst for a list of properties. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">format</td><td>see enum mpv_format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Option value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>error code </dd></dl>

</div>
</div>
<a id="af3df8b17cb495fb877af6957520df0ed" name="af3df8b17cb495fb877af6957520df0ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3df8b17cb495fb877af6957520df0ed">&#9670;&#160;</a></span>mpv_set_property_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int mpv_set_property_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>reply_userdata</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a8de0a5cfaeed2adfe0c344df68ba292f">mpv_format</a></td>          <td class="paramname"><span class="paramname"><em>format</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a property asynchronously. You will receive the result of the operation as MPV_EVENT_SET_PROPERTY_REPLY event. The <a class="el" href="structmpv__event.html#af671002ddcb1bf25e23230a81cfaa498">mpv_event.error</a> field will contain the result status of the operation. Otherwise, this function is similar to <a class="el" href="#a95b9322b70a70cc09f8204d689df97a3">mpv_set_property()</a>.</p>
<p>Safe to be called from mpv render API threads.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">reply_userdata</td><td>see section about asynchronous calls </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">name</td><td>The property name. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">format</td><td>see enum mpv_format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Option value. The value will be copied by the function. It will never be modified by the client API. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>error code if sending the request failed </dd></dl>

</div>
</div>
<a id="a292257755e6b358b045254ef1e4534d8" name="a292257755e6b358b045254ef1e4534d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a292257755e6b358b045254ef1e4534d8">&#9670;&#160;</a></span>mpv_set_property_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int mpv_set_property_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience function to set a property to a string value.</p>
<p>This is like calling <a class="el" href="#a95b9322b70a70cc09f8204d689df97a3">mpv_set_property()</a> with MPV_FORMAT_STRING. </p>

</div>
</div>
<a id="a54b24fa9076b9c0ca5f988709d20e736" name="a54b24fa9076b9c0ca5f988709d20e736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54b24fa9076b9c0ca5f988709d20e736">&#9670;&#160;</a></span>mpv_set_wakeup_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> void mpv_set_wakeup_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *d)</td>          <td class="paramname"><span class="paramname"><em>cb</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a custom function that should be called when there are new events. Use this if blocking in <a class="el" href="#a14715be5aab817bb71770f711b64102a">mpv_wait_event()</a> to wait for new events is not feasible.</p>
<p>Keep in mind that the callback will be called from foreign threads. You must not make any assumptions of the environment, and you must return as soon as possible (i.e. no long blocking waits). Exiting the callback through any other means than a normal return is forbidden (no throwing exceptions, no longjmp() calls). You must not change any local thread state (such as the C floating point environment).</p>
<p>You are not allowed to call any client API functions inside of the callback. In particular, you should not do any processing in the callback, but wake up another thread that does all the work. The callback is meant strictly for notification only, and is called from arbitrary core parts of the player, that make no considerations for reentrant API use or allowing the callee to spend a lot of time doing other things. Keep in mind that it's also possible that the callback is called from a thread while a mpv API function is called (i.e. it can be reentrant).</p>
<p>In general, the client API expects you to call <a class="el" href="#a14715be5aab817bb71770f711b64102a">mpv_wait_event()</a> to receive notifications, and the wakeup callback is merely a helper utility to make this easier in certain situations. Note that it's possible that there's only one wakeup callback invocation for multiple events. You should call <a class="el" href="#a14715be5aab817bb71770f711b64102a">mpv_wait_event()</a> with no timeout until MPV_EVENT_NONE is reached, at which point the event queue is empty.</p>
<p>If you actually want to do processing in a callback, spawn a thread that does nothing but call <a class="el" href="#a14715be5aab817bb71770f711b64102a">mpv_wait_event()</a> in a loop and dispatches the result to a callback.</p>
<p>Only one wakeup callback can be set.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>function that should be called if a wakeup is required </td></tr>
    <tr><td class="paramname">d</td><td>arbitrary userdata passed to cb </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a831ff5d62abb8eab842af9ec23f182a6" name="a831ff5d62abb8eab842af9ec23f182a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a831ff5d62abb8eab842af9ec23f182a6">&#9670;&#160;</a></span>mpv_terminate_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> void mpv_terminate_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to <a class="el" href="#ae12b97104f3bbe302d96260c33728f07">mpv_destroy()</a>, but brings the player and all clients down as well, and waits until all of them are destroyed. This function blocks. The advantage over <a class="el" href="#ae12b97104f3bbe302d96260c33728f07">mpv_destroy()</a> is that while <a class="el" href="#ae12b97104f3bbe302d96260c33728f07">mpv_destroy()</a> merely detaches the client handle from the player, this function quits the player, waits until all other clients are destroyed (i.e. all mpv_handles are detached), and also waits for the final termination of the player.</p>
<p>Since <a class="el" href="#ae12b97104f3bbe302d96260c33728f07">mpv_destroy()</a> is called somewhere on the way, it's not safe to call other functions concurrently on the same context.</p>
<p>Since mpv client API version 1.29: The first call on any mpv_handle will block until the core is destroyed. This means it will wait until other mpv_handle have been destroyed. If you want asynchronous destruction, just run the "quit" command, and then react to the MPV_EVENT_SHUTDOWN event. If another mpv_handle already called <a class="el" href="#a831ff5d62abb8eab842af9ec23f182a6">mpv_terminate_destroy()</a>, this call will not actually block. It will destroy the mpv_handle, and exit immediately, while other mpv_handles might still be uninitializing.</p>
<p>Before mpv client API version 1.29: If this is called on a mpv_handle that was not created with <a class="el" href="#acabb8d28abfb2614024eaa58a4de36e8">mpv_create()</a>, this function will merely send a quit command and then call <a class="el" href="#ae12b97104f3bbe302d96260c33728f07">mpv_destroy()</a>, without waiting for the actual shutdown. </p>
<div class="dynheader">
这是这个函数的调用关系图:</div>
<div class="dyncontent">
<div class="center"><img src="client_8h_a831ff5d62abb8eab842af9ec23f182a6_icgraph.png" border="0" usemap="#aclient_8h_a831ff5d62abb8eab842af9ec23f182a6_icgraph" alt=""/></div>
<map name="aclient_8h_a831ff5d62abb8eab842af9ec23f182a6_icgraph" id="aclient_8h_a831ff5d62abb8eab842af9ec23f182a6_icgraph">
<area shape="rect" title=" " alt="" coords="201,5,356,32"/>
<area shape="rect" href="class_controller.html#a8351d2a68600034af0dbd1834bb21374" title=" " alt="" coords="5,5,153,32"/>
<area shape="poly" title=" " alt="" coords="185,21,153,21,153,16,185,16"/>
</map>
</div>

</div>
</div>
<a id="a8cc02c1e7054f92c7e7502d88336d57e" name="a8cc02c1e7054f92c7e7502d88336d57e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cc02c1e7054f92c7e7502d88336d57e">&#9670;&#160;</a></span>mpv_unobserve_property()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int mpv_unobserve_property </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *</td>          <td class="paramname"><span class="paramname"><em>mpv</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>registered_reply_userdata</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Undo <a class="el" href="#af3d2b287c0f994fb3649c1a1bf85591e">mpv_observe_property()</a>. This will remove all observed properties for which the given number was passed as reply_userdata to mpv_observe_property.</p>
<p>Safe to be called from mpv render API threads.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">registered_reply_userdata</td><td>ID that was passed to mpv_observe_property </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>negative value is an error code, &gt;=0 is number of removed properties on success (includes the case when 0 were removed) </dd></dl>

</div>
</div>
<a id="a4df66904a005a9c15b6cb9f4e7caa223" name="a4df66904a005a9c15b6cb9f4e7caa223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4df66904a005a9c15b6cb9f4e7caa223">&#9670;&#160;</a></span>mpv_wait_async_requests()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> void mpv_wait_async_requests </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Block until all asynchronous requests are done. This affects functions like <a class="el" href="#aa0eb9659d717174434d6c69bb0be089b">mpv_command_async()</a>, which return immediately and return their result as events.</p>
<p>This is a helper, and somewhat equivalent to calling <a class="el" href="#a14715be5aab817bb71770f711b64102a">mpv_wait_event()</a> in a loop until all known asynchronous requests have sent their reply as event, except that the event queue is not emptied.</p>
<p>In case you called mpv_suspend() before, this will also forcibly reset the suspend counter of the given handle. </p>

</div>
</div>
<a id="a14715be5aab817bb71770f711b64102a" name="a14715be5aab817bb71770f711b64102a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14715be5aab817bb71770f711b64102a">&#9670;&#160;</a></span>mpv_wait_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> <a class="el" href="structmpv__event.html">mpv_event</a> * mpv_wait_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>timeout</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait for the next event, or until the timeout expires, or if another thread makes a call to <a class="el" href="#a365ef47a0f79325577c714799bb4899e">mpv_wakeup()</a>. Passing 0 as timeout will never wait, and is suitable for polling.</p>
<p>The internal event queue has a limited size (per client handle). If you don't empty the event queue quickly enough with <a class="el" href="#a14715be5aab817bb71770f711b64102a">mpv_wait_event()</a>, it will overflow and silently discard further events. If this happens, making asynchronous requests will fail as well (with MPV_ERROR_EVENT_QUEUE_FULL).</p>
<p>Only one thread is allowed to call this on the same mpv_handle at a time. The API won't complain if more than one thread calls this, but it will cause race conditions in the client when accessing the shared <a class="el" href="structmpv__event.html">mpv_event</a> struct. Note that most other API functions are not restricted by this, and no API function internally calls <a class="el" href="#a14715be5aab817bb71770f711b64102a">mpv_wait_event()</a>. Additionally, concurrent calls to different mpv_handles are always safe.</p>
<p>As long as the timeout is 0, this is safe to be called from mpv render API threads.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>Timeout in seconds, after which the function returns even if no event was received. A MPV_EVENT_NONE is returned on timeout. A value of 0 will disable waiting. Negative values will wait with an infinite timeout. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>A struct containing the event ID and other data. The pointer (and fields in the struct) stay valid until the next <a class="el" href="#a14715be5aab817bb71770f711b64102a">mpv_wait_event()</a> call, or until the mpv_handle is destroyed. You must not write to the struct, and all memory referenced by it will be automatically released by the API on the next <a class="el" href="#a14715be5aab817bb71770f711b64102a">mpv_wait_event()</a> call, or when the context is destroyed. The return value is never NULL. </dd></dl>

</div>
</div>
<a id="a365ef47a0f79325577c714799bb4899e" name="a365ef47a0f79325577c714799bb4899e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a365ef47a0f79325577c714799bb4899e">&#9670;&#160;</a></span>mpv_wakeup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> void mpv_wakeup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interrupt the current <a class="el" href="#a14715be5aab817bb71770f711b64102a">mpv_wait_event()</a> call. This will wake up the thread currently waiting in <a class="el" href="#a14715be5aab817bb71770f711b64102a">mpv_wait_event()</a>. If no thread is waiting, the next <a class="el" href="#a14715be5aab817bb71770f711b64102a">mpv_wait_event()</a> call will return immediately (this is to avoid lost wakeups).</p>
<p><a class="el" href="#a14715be5aab817bb71770f711b64102a">mpv_wait_event()</a> will receive a MPV_EVENT_NONE if it's woken up due to this call. But note that this dummy event might be skipped if there are already other events queued. All what counts is that the waiting thread is woken up at all.</p>
<p>Safe to be called from mpv render API threads. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
制作者&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>

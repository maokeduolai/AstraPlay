<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AstraPlay: F:/QtProject/AstraPlay/src/include/mpv/stream_cb.h 文件参考</title>
<link rel="icon" href="AstraPlay_Logo_Small.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="AstraPlay_Logo_Small.png"/></td>
  <td id="projectalign">
   <div id="projectname">AstraPlay<span id="projectnumber">&#160;v1.0.2</span>
   </div>
   <div id="projectbrief">基于libmpv与Qt5框架的视频播放器</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.10.0 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>首页</span></a></li>
      <li><a href="pages.html"><span>相关页面</span></a></li>
      <li><a href="namespaces.html"><span>命名空间</span></a></li>
      <li><a href="annotated.html"><span>类</span></a></li>
      <li class="current"><a href="files.html"><span>文件</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>文件列表</span></a></li>
      <li><a href="globals.html"><span>文件成员</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_b0856f6b0d80ccb263b2f415c91f9e17.html">include</a></li><li class="navelem"><a class="el" href="dir_85e4b8678a4e308299dd4557438491b5.html">mpv</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">类</a> &#124;
<a href="#typedef-members">类型定义</a> &#124;
<a href="#func-members">函数</a>  </div>
  <div class="headertitle"><div class="title">stream_cb.h 文件参考</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="client_8h_source.html">client.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
stream_cb.h 的引用(Include)关系图:</div>
<div class="dyncontent">
<div class="center"><img src="stream__cb_8h__incl.png" border="0" usemap="#a_f_1_2_qt_project_2_astra_play_2src_2include_2mpv_2stream__cb_8h" alt=""/></div>
<map name="a_f_1_2_qt_project_2_astra_play_2src_2include_2mpv_2stream__cb_8h" id="a_f_1_2_qt_project_2_astra_play_2src_2include_2mpv_2stream__cb_8h">
<area shape="rect" title=" " alt="" coords="5,5,197,48"/>
<area shape="rect" href="client_8h.html" title=" " alt="" coords="69,96,133,123"/>
<area shape="poly" title=" " alt="" coords="104,49,104,80,98,80,98,49"/>
<area shape="rect" title=" " alt="" coords="23,171,91,197"/>
<area shape="poly" title=" " alt="" coords="96,125,75,159,70,156,91,122"/>
<area shape="rect" title=" " alt="" coords="114,171,179,197"/>
<area shape="poly" title=" " alt="" coords="111,122,133,156,128,159,107,125"/>
</map>
</div>
</div>
<p><a href="stream__cb_8h_source.html">浏览源代码.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
类</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpv__stream__cb__info.html">mpv_stream_cb_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
类型定义</h2></td></tr>
<tr class="memitem:a0c77a36993c24015e564838749af6d44" id="r_a0c77a36993c24015e564838749af6d44"><td class="memItemLeft" align="right" valign="top">typedef int64_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c77a36993c24015e564838749af6d44">mpv_stream_cb_read_fn</a>) (void *cookie, char *buf, uint64_t nbytes)</td></tr>
<tr class="separator:a0c77a36993c24015e564838749af6d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00326a6e7614c0339c2c23836bcc6bee" id="r_a00326a6e7614c0339c2c23836bcc6bee"><td class="memItemLeft" align="right" valign="top">typedef int64_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00326a6e7614c0339c2c23836bcc6bee">mpv_stream_cb_seek_fn</a>) (void *cookie, int64_t offset)</td></tr>
<tr class="separator:a00326a6e7614c0339c2c23836bcc6bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad367292ab8aadca2ed314fcc976bc455" id="r_ad367292ab8aadca2ed314fcc976bc455"><td class="memItemLeft" align="right" valign="top">typedef int64_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad367292ab8aadca2ed314fcc976bc455">mpv_stream_cb_size_fn</a>) (void *cookie)</td></tr>
<tr class="separator:ad367292ab8aadca2ed314fcc976bc455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77760c9adc8d59f8eb116eb14944c6df" id="r_a77760c9adc8d59f8eb116eb14944c6df"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77760c9adc8d59f8eb116eb14944c6df">mpv_stream_cb_close_fn</a>) (void *cookie)</td></tr>
<tr class="separator:a77760c9adc8d59f8eb116eb14944c6df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe1aa7e1f1f933a93661cc15f9c03f3" id="r_a4fe1aa7e1f1f933a93661cc15f9c03f3"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fe1aa7e1f1f933a93661cc15f9c03f3">mpv_stream_cb_cancel_fn</a>) (void *cookie)</td></tr>
<tr class="separator:a4fe1aa7e1f1f933a93661cc15f9c03f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24e26ff715ed7a9b05862054bf8ea16" id="r_ac24e26ff715ed7a9b05862054bf8ea16"><td class="memItemLeft" align="right" valign="top">typedef struct mpv_stream_cb_info&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac24e26ff715ed7a9b05862054bf8ea16">mpv_stream_cb_info</a></td></tr>
<tr class="separator:ac24e26ff715ed7a9b05862054bf8ea16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a983a47052a190281dc25d4c96800b" id="r_a36a983a47052a190281dc25d4c96800b"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36a983a47052a190281dc25d4c96800b">mpv_stream_cb_open_ro_fn</a>) (void *user_data, char *uri, <a class="el" href="structmpv__stream__cb__info.html">mpv_stream_cb_info</a> *info)</td></tr>
<tr class="separator:a36a983a47052a190281dc25d4c96800b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
函数</h2></td></tr>
<tr class="memitem:a9df00b7d068a238bd71dedc96a3cfa23" id="r_a9df00b7d068a238bd71dedc96a3cfa23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="client_8h.html#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9df00b7d068a238bd71dedc96a3cfa23">mpv_stream_cb_add_ro</a> (<a class="el" href="client_8h.html#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *ctx, const char *protocol, void *user_data, <a class="el" href="#a36a983a47052a190281dc25d4c96800b">mpv_stream_cb_open_ro_fn</a> open_fn)</td></tr>
<tr class="separator:a9df00b7d068a238bd71dedc96a3cfa23"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">类型定义说明</h2>
<a id="a4fe1aa7e1f1f933a93661cc15f9c03f3" name="a4fe1aa7e1f1f933a93661cc15f9c03f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fe1aa7e1f1f933a93661cc15f9c03f3">&#9670;&#160;</a></span>mpv_stream_cb_cancel_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* mpv_stream_cb_cancel_fn) (void *cookie)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cancel callback used to implement a custom stream.</p>
<p>This callback is used to interrupt any current or future read and seek operations. It will be called from a separate thread than the demux thread, and should not block.</p>
<p>This callback can be NULL.</p>
<p>Available since API 1.106.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cookie</td><td>opaque cookie identifying the stream, returned from mpv_stream_cb_open_fn </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="stream__cb_8h_source.html">stream_cb.h</a> 第 <a class="el" href="stream__cb_8h_source.html#l00164">164</a> 行定义.</p>

</div>
</div>
<a id="a77760c9adc8d59f8eb116eb14944c6df" name="a77760c9adc8d59f8eb116eb14944c6df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77760c9adc8d59f8eb116eb14944c6df">&#9670;&#160;</a></span>mpv_stream_cb_close_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* mpv_stream_cb_close_fn) (void *cookie)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close callback used to implement a custom stream.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cookie</td><td>opaque cookie identifying the stream, returned from mpv_stream_cb_open_fn </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">在文件 <a class="el" href="stream__cb_8h_source.html">stream_cb.h</a> 第 <a class="el" href="stream__cb_8h_source.html#l00148">148</a> 行定义.</p>

</div>
</div>
<a id="ac24e26ff715ed7a9b05862054bf8ea16" name="ac24e26ff715ed7a9b05862054bf8ea16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac24e26ff715ed7a9b05862054bf8ea16">&#9670;&#160;</a></span>mpv_stream_cb_info</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct mpv_stream_cb_info mpv_stream_cb_info</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>See mpv_stream_cb_open_ro_fn callback. </p>

</div>
</div>
<a id="a36a983a47052a190281dc25d4c96800b" name="a36a983a47052a190281dc25d4c96800b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36a983a47052a190281dc25d4c96800b">&#9670;&#160;</a></span>mpv_stream_cb_open_ro_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* mpv_stream_cb_open_ro_fn) (void *user_data, char *uri, <a class="el" href="structmpv__stream__cb__info.html">mpv_stream_cb_info</a> *info)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open callback used to implement a custom read-only (ro) stream. The user must set the callback fields in the passed info struct. The cookie field also can be set to store state associated to the stream instance.</p>
<p>Note that the info struct is valid only for the duration of this callback. You can't change the callbacks or the pointer to the cookie at a later point.</p>
<p>Each stream instance created by the open callback can have different callbacks.</p>
<p>The close_fn callback will terminate the stream instance. The pointers to your callbacks and cookie will be discarded, and the callbacks will not be called again.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">user_data</td><td>opaque user data provided via mpv_stream_cb_add() </td></tr>
    <tr><td class="paramname">uri</td><td>name of the stream to be opened (with protocol prefix) </td></tr>
    <tr><td class="paramname">info</td><td>fields which the user should fill </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>0 on success, MPV_ERROR_LOADING_FAILED if the URI cannot be opened. </dd></dl>

<p class="definition">在文件 <a class="el" href="stream__cb_8h_source.html">stream_cb.h</a> 第 <a class="el" href="stream__cb_8h_source.html#l00212">212</a> 行定义.</p>

</div>
</div>
<a id="a0c77a36993c24015e564838749af6d44" name="a0c77a36993c24015e564838749af6d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c77a36993c24015e564838749af6d44">&#9670;&#160;</a></span>mpv_stream_cb_read_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int64_t(* mpv_stream_cb_read_fn) (void *cookie, char *buf, uint64_t nbytes)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Warning: this API is not stable yet.</p>
<h2><a class="anchor" id="autotoc_md21"></a>
Overview</h2>
<p>This API can be used to make mpv read from a stream with a custom implementation. This interface is inspired by funopen on BSD and fopencookie on linux. The stream is backed by user-defined callbacks which can implement customized open, read, seek, size and close behaviors.</p>
<h2><a class="anchor" id="autotoc_md22"></a>
Usage</h2>
<p>Register your stream callbacks with the <a class="el" href="#a9df00b7d068a238bd71dedc96a3cfa23">mpv_stream_cb_add_ro()</a> function. You have to provide a mpv_stream_cb_open_ro_fn callback to it (open_fn argument).</p>
<p>Once registered, you can <code>loadfile myprotocol://myfile</code>. Your open_fn will be invoked with the URI and you must fill out the provided <a class="el" href="structmpv__stream__cb__info.html">mpv_stream_cb_info</a> struct. This includes your stream callbacks (like read_fn), and an opaque cookie, which will be passed as the first argument to all the remaining stream callbacks.</p>
<p>Note that your custom callbacks must not invoke mpv APIs as that would cause a deadlock. (Unless you call a different mpv_handle than the one the callback was registered for, and the mpv_handles refer to different mpv instances.)</p>
<h2><a class="anchor" id="autotoc_md23"></a>
Stream lifetime</h2>
<p>A stream remains valid until its close callback has been called. It's up to mpv to call the close callback, and the mpv user cannot close it directly with the stream_cb API.</p>
<p>For example, if you consider your custom stream to become suddenly invalid (maybe because the underlying stream died), mpv will continue using your stream. All you can do is returning errors from each callback, until mpv gives up and closes it.</p>
<h2><a class="anchor" id="autotoc_md24"></a>
Protocol registration and lifetime</h2>
<p>Protocols remain registered until the mpv instance is terminated. This means in particular that it can outlive the mpv_handle that was used to register it, but once <a class="el" href="client_8h.html#a831ff5d62abb8eab842af9ec23f182a6">mpv_terminate_destroy()</a> is called, your registered callbacks will not be called again.</p>
<p>Protocol unregistration is finished after the mpv core has been destroyed (e.g. after <a class="el" href="client_8h.html#a831ff5d62abb8eab842af9ec23f182a6">mpv_terminate_destroy()</a> has returned).</p>
<p>If you do not call <a class="el" href="client_8h.html#a831ff5d62abb8eab842af9ec23f182a6">mpv_terminate_destroy()</a> yourself (e.g. plugin-style code), you will have to deal with the registration or even streams outliving your code. Here are some possible ways to do this:</p><ul>
<li>call <a class="el" href="client_8h.html#a831ff5d62abb8eab842af9ec23f182a6">mpv_terminate_destroy()</a>, which destroys the core, and will make sure all streams are closed once this function returns</li>
<li>you refcount all resources your stream "cookies" reference, so that it doesn't matter if streams live longer than expected</li>
<li>create "cancellation" semantics: after your protocol has been unregistered, notify all your streams that are still opened, and make them drop all referenced resources - then return errors from the stream callbacks as long as the stream is still opened Read callback used to implement a custom stream. The semantics of the callback match read(2) in blocking mode. Short reads are allowed (you can return less bytes than requested, and mpv will retry reading the rest with another call). If no data can be immediately read, the callback must block until there is new data. A return of 0 will be interpreted as final EOF, although mpv might retry the read, or seek to a different position.</li>
</ul>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cookie</td><td>opaque cookie identifying the stream, returned from mpv_stream_cb_open_fn </td></tr>
    <tr><td class="paramname">buf</td><td>buffer to read data into </td></tr>
    <tr><td class="paramname">size</td><td>of the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>number of bytes read into the buffer </dd>
<dd>
0 on EOF </dd>
<dd>
-1 on error </dd></dl>

<p class="definition">在文件 <a class="el" href="stream__cb_8h_source.html">stream_cb.h</a> 第 <a class="el" href="stream__cb_8h_source.html#l00106">106</a> 行定义.</p>

</div>
</div>
<a id="a00326a6e7614c0339c2c23836bcc6bee" name="a00326a6e7614c0339c2c23836bcc6bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00326a6e7614c0339c2c23836bcc6bee">&#9670;&#160;</a></span>mpv_stream_cb_seek_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int64_t(* mpv_stream_cb_seek_fn) (void *cookie, int64_t offset)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Seek callback used to implement a custom stream.</p>
<p>Note that mpv will issue a seek to position 0 immediately after opening. This is used to test whether the stream is seekable (since seekability might depend on the URI contents, not just the protocol). Return MPV_ERROR_UNSUPPORTED if seeking is not implemented for this stream. This seek also serves to establish the fact that streams start at position 0.</p>
<p>This callback can be NULL, in which it behaves as if always returning MPV_ERROR_UNSUPPORTED.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cookie</td><td>opaque cookie identifying the stream, returned from mpv_stream_cb_open_fn </td></tr>
    <tr><td class="paramname">offset</td><td>target absolute stream position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>the resulting offset of the stream MPV_ERROR_UNSUPPORTED or MPV_ERROR_GENERIC if the seek failed </dd></dl>

<p class="definition">在文件 <a class="el" href="stream__cb_8h_source.html">stream_cb.h</a> 第 <a class="el" href="stream__cb_8h_source.html#l00126">126</a> 行定义.</p>

</div>
</div>
<a id="ad367292ab8aadca2ed314fcc976bc455" name="ad367292ab8aadca2ed314fcc976bc455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad367292ab8aadca2ed314fcc976bc455">&#9670;&#160;</a></span>mpv_stream_cb_size_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int64_t(* mpv_stream_cb_size_fn) (void *cookie)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Size callback used to implement a custom stream.</p>
<p>Return MPV_ERROR_UNSUPPORTED if no size is known.</p>
<p>This callback can be NULL, in which it behaves as if always returning MPV_ERROR_UNSUPPORTED.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">cookie</td><td>opaque cookie identifying the stream, returned from mpv_stream_cb_open_fn </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>the total size in bytes of the stream </dd></dl>

<p class="definition">在文件 <a class="el" href="stream__cb_8h_source.html">stream_cb.h</a> 第 <a class="el" href="stream__cb_8h_source.html#l00140">140</a> 行定义.</p>

</div>
</div>
<h2 class="groupheader">函数说明</h2>
<a id="a9df00b7d068a238bd71dedc96a3cfa23" name="a9df00b7d068a238bd71dedc96a3cfa23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9df00b7d068a238bd71dedc96a3cfa23">&#9670;&#160;</a></span>mpv_stream_cb_add_ro()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="client_8h.html#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int mpv_stream_cb_add_ro </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="client_8h.html#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>protocol</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a36a983a47052a190281dc25d4c96800b">mpv_stream_cb_open_ro_fn</a></td>          <td class="paramname"><span class="paramname"><em>open_fn</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a custom stream protocol. This will register a protocol handler under the given protocol prefix, and invoke the given callbacks if an URI with the matching protocol prefix is opened.</p>
<p>The "ro" is for read-only - only read-only streams can be registered with this function.</p>
<p>The callback remains registered until the mpv core is registered.</p>
<p>If a custom stream with the same name is already registered, then the MPV_ERROR_INVALID_PARAMETER error is returned.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">protocol</td><td>protocol prefix, for example "foo" for "foo://" URIs </td></tr>
    <tr><td class="paramname">user_data</td><td>opaque pointer passed into the mpv_stream_cb_open_fn callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>error code </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
制作者&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>

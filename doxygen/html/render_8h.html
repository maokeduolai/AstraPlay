<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AstraPlay: F:/QtProject/AstraPlay/src/include/mpv/render.h 文件参考</title>
<link rel="icon" href="AstraPlay_Logo_Small.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="AstraPlay_Logo_Small.png"/></td>
  <td id="projectalign">
   <div id="projectname">AstraPlay<span id="projectnumber">&#160;v1.0.2</span>
   </div>
   <div id="projectbrief">基于libmpv与Qt5框架的视频播放器</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.10.0 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>首页</span></a></li>
      <li><a href="pages.html"><span>相关页面</span></a></li>
      <li><a href="namespaces.html"><span>命名空间</span></a></li>
      <li><a href="annotated.html"><span>类</span></a></li>
      <li class="current"><a href="files.html"><span>文件</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>文件列表</span></a></li>
      <li><a href="globals.html"><span>文件成员</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_b0856f6b0d80ccb263b2f415c91f9e17.html">include</a></li><li class="navelem"><a class="el" href="dir_85e4b8678a4e308299dd4557438491b5.html">mpv</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">类</a> &#124;
<a href="#define-members">宏定义</a> &#124;
<a href="#typedef-members">类型定义</a> &#124;
<a href="#enum-members">枚举</a> &#124;
<a href="#func-members">函数</a>  </div>
  <div class="headertitle"><div class="title">render.h 文件参考</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="client_8h_source.html">client.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
render.h 的引用(Include)关系图:</div>
<div class="dyncontent">
<div class="center"><img src="render_8h__incl.png" border="0" usemap="#a_f_1_2_qt_project_2_astra_play_2src_2include_2mpv_2render_8h" alt=""/></div>
<map name="a_f_1_2_qt_project_2_astra_play_2src_2include_2mpv_2render_8h" id="a_f_1_2_qt_project_2_astra_play_2src_2include_2mpv_2render_8h">
<area shape="rect" title=" " alt="" coords="5,5,172,48"/>
<area shape="rect" href="client_8h.html" title=" " alt="" coords="57,96,120,123"/>
<area shape="poly" title=" " alt="" coords="91,49,91,80,86,80,86,49"/>
<area shape="rect" title=" " alt="" coords="11,171,78,197"/>
<area shape="poly" title=" " alt="" coords="83,125,62,159,58,156,79,122"/>
<area shape="rect" title=" " alt="" coords="102,171,166,197"/>
<area shape="poly" title=" " alt="" coords="99,122,120,156,116,159,94,125"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
此图展示该文件直接或间接的被哪些文件引用了:</div>
<div class="dyncontent">
<div class="center"><img src="render_8h__dep__incl.png" border="0" usemap="#a_f_1_2_qt_project_2_astra_play_2src_2include_2mpv_2render_8hdep" alt=""/></div>
<map name="a_f_1_2_qt_project_2_astra_play_2src_2include_2mpv_2render_8hdep" id="a_f_1_2_qt_project_2_astra_play_2src_2include_2mpv_2render_8hdep">
<area shape="rect" title=" " alt="" coords="14,5,180,48"/>
<area shape="rect" href="render__gl_8h.html" title=" " alt="" coords="5,96,189,139"/>
<area shape="poly" title=" " alt="" coords="100,64,100,96,94,96,94,64"/>
</map>
</div>
</div>
<p><a href="render_8h_source.html">浏览源代码.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
类</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpv__render__param.html">mpv_render_param</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmpv__render__frame__info.html">mpv_render_frame_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
宏定义</h2></td></tr>
<tr class="memitem:a64dcaec756f2b70f492bf254af3d0ec9" id="r_a64dcaec756f2b70f492bf254af3d0ec9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64dcaec756f2b70f492bf254af3d0ec9">MPV_RENDER_PARAM_DRM_OSD_SIZE</a>&#160;&#160;&#160;<a class="el" href="#ac10cb1981663e694c377824212ef3ee0a41507e24190dd71b62517a40f9df10ff">MPV_RENDER_PARAM_DRM_DRAW_SURFACE_SIZE</a></td></tr>
<tr class="separator:a64dcaec756f2b70f492bf254af3d0ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8784066f41f06bd29406d3f3dd25de" id="r_a6d8784066f41f06bd29406d3f3dd25de"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d8784066f41f06bd29406d3f3dd25de">MPV_RENDER_API_TYPE_OPENGL</a>&#160;&#160;&#160;&quot;opengl&quot;</td></tr>
<tr class="separator:a6d8784066f41f06bd29406d3f3dd25de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bebdcbfd587ac3e17477d09ecc5c683" id="r_a6bebdcbfd587ac3e17477d09ecc5c683"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6bebdcbfd587ac3e17477d09ecc5c683">MPV_RENDER_API_TYPE_SW</a>&#160;&#160;&#160;&quot;sw&quot;</td></tr>
<tr class="separator:a6bebdcbfd587ac3e17477d09ecc5c683"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
类型定义</h2></td></tr>
<tr class="memitem:ae2c9749016fe3762f7e18472ad902ec0" id="r_ae2c9749016fe3762f7e18472ad902ec0"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="#ae2c9749016fe3762f7e18472ad902ec0">mpv_render_context</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2c9749016fe3762f7e18472ad902ec0">mpv_render_context</a></td></tr>
<tr class="separator:ae2c9749016fe3762f7e18472ad902ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b915c951c37a8a80936e25b7d2e7779" id="r_a0b915c951c37a8a80936e25b7d2e7779"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="#ac10cb1981663e694c377824212ef3ee0">mpv_render_param_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b915c951c37a8a80936e25b7d2e7779">mpv_render_param_type</a></td></tr>
<tr class="separator:a0b915c951c37a8a80936e25b7d2e7779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9bff7a3d8ff3e2a992282b8f736571e" id="r_ab9bff7a3d8ff3e2a992282b8f736571e"><td class="memItemLeft" align="right" valign="top">typedef struct mpv_render_param&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9bff7a3d8ff3e2a992282b8f736571e">mpv_render_param</a></td></tr>
<tr class="separator:ab9bff7a3d8ff3e2a992282b8f736571e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d7b5c5b6762484ea191860a5fdb135" id="r_a93d7b5c5b6762484ea191860a5fdb135"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="#a3706d2f8d449ca817136c993d2e6e015">mpv_render_frame_info_flag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93d7b5c5b6762484ea191860a5fdb135">mpv_render_frame_info_flag</a></td></tr>
<tr class="separator:a93d7b5c5b6762484ea191860a5fdb135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebaf6c6904d34ebbe6dc228c5d4cf443" id="r_aebaf6c6904d34ebbe6dc228c5d4cf443"><td class="memItemLeft" align="right" valign="top">typedef struct mpv_render_frame_info&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebaf6c6904d34ebbe6dc228c5d4cf443">mpv_render_frame_info</a></td></tr>
<tr class="separator:aebaf6c6904d34ebbe6dc228c5d4cf443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa976582e31273bcea01cd6d862a9a332" id="r_aa976582e31273bcea01cd6d862a9a332"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa976582e31273bcea01cd6d862a9a332">mpv_render_update_fn</a>) (void *cb_ctx)</td></tr>
<tr class="separator:aa976582e31273bcea01cd6d862a9a332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f83d1161ed49a29c6db4782a6a02ee" id="r_a77f83d1161ed49a29c6db4782a6a02ee"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="#ade728e3f6e75aab0259e51991968e481">mpv_render_update_flag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77f83d1161ed49a29c6db4782a6a02ee">mpv_render_context_flag</a></td></tr>
<tr class="separator:a77f83d1161ed49a29c6db4782a6a02ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
枚举</h2></td></tr>
<tr class="memitem:ac10cb1981663e694c377824212ef3ee0" id="r_ac10cb1981663e694c377824212ef3ee0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac10cb1981663e694c377824212ef3ee0">mpv_render_param_type</a> { <br />
&#160;&#160;<a class="el" href="#ac10cb1981663e694c377824212ef3ee0af546b92d3d931ef18ddab987940ab15f">MPV_RENDER_PARAM_INVALID</a> = 0
, <a class="el" href="#ac10cb1981663e694c377824212ef3ee0a5764b1f4daccc7ec76d04b95299f55aa">MPV_RENDER_PARAM_API_TYPE</a> = 1
, <a class="el" href="#ac10cb1981663e694c377824212ef3ee0a1821fd6ee9b1f12f30e73368bd66b2b3">MPV_RENDER_PARAM_OPENGL_INIT_PARAMS</a> = 2
, <a class="el" href="#ac10cb1981663e694c377824212ef3ee0a993215484355e7eddf30dff9dca37c27">MPV_RENDER_PARAM_OPENGL_FBO</a> = 3
, <br />
&#160;&#160;<a class="el" href="#ac10cb1981663e694c377824212ef3ee0aead5b92c56ac4f38c5585547bd01d30b">MPV_RENDER_PARAM_FLIP_Y</a> = 4
, <a class="el" href="#ac10cb1981663e694c377824212ef3ee0a89ba84bc2924f868b471031fc1449c55">MPV_RENDER_PARAM_DEPTH</a> = 5
, <a class="el" href="#ac10cb1981663e694c377824212ef3ee0ae42158d5e877a4509dd4ed22297a37b3">MPV_RENDER_PARAM_ICC_PROFILE</a> = 6
, <a class="el" href="#ac10cb1981663e694c377824212ef3ee0a7bdb36791bf4200ceaf2ffe1a31e29dc">MPV_RENDER_PARAM_AMBIENT_LIGHT</a> = 7
, <br />
&#160;&#160;<a class="el" href="#ac10cb1981663e694c377824212ef3ee0abdcd4db20a148c056f0868ad3a3d4e36">MPV_RENDER_PARAM_X11_DISPLAY</a> = 8
, <a class="el" href="#ac10cb1981663e694c377824212ef3ee0aa9f339165fd8ab3cdf0bfe2242040111">MPV_RENDER_PARAM_WL_DISPLAY</a> = 9
, <a class="el" href="#ac10cb1981663e694c377824212ef3ee0a048ff8b9e379ed5e4b35757ab6d354b3">MPV_RENDER_PARAM_ADVANCED_CONTROL</a> = 10
, <a class="el" href="#ac10cb1981663e694c377824212ef3ee0ae7f1332a83b97b76915d43c071ec2b16">MPV_RENDER_PARAM_NEXT_FRAME_INFO</a> = 11
, <br />
&#160;&#160;<a class="el" href="#ac10cb1981663e694c377824212ef3ee0a6a778d6edb83567c544046263c970ee7">MPV_RENDER_PARAM_BLOCK_FOR_TARGET_TIME</a> = 12
, <a class="el" href="#ac10cb1981663e694c377824212ef3ee0a44e483a9b77c4e9ee5daee1a71b7dd14">MPV_RENDER_PARAM_SKIP_RENDERING</a> = 13
, <a class="el" href="#ac10cb1981663e694c377824212ef3ee0a238c4273b69dcd60c6b875cfd3fc41a1">MPV_RENDER_PARAM_DRM_DISPLAY</a> = 14
, <a class="el" href="#ac10cb1981663e694c377824212ef3ee0a41507e24190dd71b62517a40f9df10ff">MPV_RENDER_PARAM_DRM_DRAW_SURFACE_SIZE</a> = 15
, <br />
&#160;&#160;<a class="el" href="#ac10cb1981663e694c377824212ef3ee0a7c172f2aeb1cb25c01bda0e482c41b66">MPV_RENDER_PARAM_DRM_DISPLAY_V2</a> = 16
, <a class="el" href="#ac10cb1981663e694c377824212ef3ee0af1970a55f4e46d457d43d6f1a71fe552">MPV_RENDER_PARAM_SW_SIZE</a> = 17
, <a class="el" href="#ac10cb1981663e694c377824212ef3ee0a573360e4ab75761e517f2745d2a13a07">MPV_RENDER_PARAM_SW_FORMAT</a> = 18
, <a class="el" href="#ac10cb1981663e694c377824212ef3ee0a066750dd977606998eb66d9b2e87da0a">MPV_RENDER_PARAM_SW_STRIDE</a> = 19
, <br />
&#160;&#160;<a class="el" href="#ac10cb1981663e694c377824212ef3ee0a81f0e9c7bd7868dbac532be9de6c5632">MPV_RENDER_PARAM_SW_POINTER</a> = 20
<br />
 }</td></tr>
<tr class="separator:ac10cb1981663e694c377824212ef3ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3706d2f8d449ca817136c993d2e6e015" id="r_a3706d2f8d449ca817136c993d2e6e015"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3706d2f8d449ca817136c993d2e6e015">mpv_render_frame_info_flag</a> { <a class="el" href="#a3706d2f8d449ca817136c993d2e6e015ad9b24f90e1f5b0c22abf7657e1425acf">MPV_RENDER_FRAME_INFO_PRESENT</a> = 1 &lt;&lt; 0
, <a class="el" href="#a3706d2f8d449ca817136c993d2e6e015ad0e0815285dc8cc5d7aa96db319e25f8">MPV_RENDER_FRAME_INFO_REDRAW</a> = 1 &lt;&lt; 1
, <a class="el" href="#a3706d2f8d449ca817136c993d2e6e015a3d748e2e67b49defc57db3715bf98306">MPV_RENDER_FRAME_INFO_REPEAT</a> = 1 &lt;&lt; 2
, <a class="el" href="#a3706d2f8d449ca817136c993d2e6e015a5a06dde0f579f92419879ed2c3996c0d">MPV_RENDER_FRAME_INFO_BLOCK_VSYNC</a> = 1 &lt;&lt; 3
 }</td></tr>
<tr class="separator:a3706d2f8d449ca817136c993d2e6e015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade728e3f6e75aab0259e51991968e481" id="r_ade728e3f6e75aab0259e51991968e481"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade728e3f6e75aab0259e51991968e481">mpv_render_update_flag</a> { <a class="el" href="#ade728e3f6e75aab0259e51991968e481a2dcb3d9854e2a3987024c87b8e9eadc0">MPV_RENDER_UPDATE_FRAME</a> = 1 &lt;&lt; 0
 }</td></tr>
<tr class="separator:ade728e3f6e75aab0259e51991968e481"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
函数</h2></td></tr>
<tr class="memitem:a6326414507775cef9b21b5bbee1553d8" id="r_a6326414507775cef9b21b5bbee1553d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="client_8h.html#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6326414507775cef9b21b5bbee1553d8">mpv_render_context_create</a> (<a class="el" href="#ae2c9749016fe3762f7e18472ad902ec0">mpv_render_context</a> **res, <a class="el" href="client_8h.html#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *mpv, <a class="el" href="structmpv__render__param.html">mpv_render_param</a> *params)</td></tr>
<tr class="separator:a6326414507775cef9b21b5bbee1553d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a817e67dc0a7a56c13911bbe01627aaaf" id="r_a817e67dc0a7a56c13911bbe01627aaaf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="client_8h.html#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a817e67dc0a7a56c13911bbe01627aaaf">mpv_render_context_set_parameter</a> (<a class="el" href="#ae2c9749016fe3762f7e18472ad902ec0">mpv_render_context</a> *ctx, <a class="el" href="structmpv__render__param.html">mpv_render_param</a> param)</td></tr>
<tr class="separator:a817e67dc0a7a56c13911bbe01627aaaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35d7678d61a6e5cc01b9670e2f0eccd" id="r_aa35d7678d61a6e5cc01b9670e2f0eccd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="client_8h.html#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa35d7678d61a6e5cc01b9670e2f0eccd">mpv_render_context_get_info</a> (<a class="el" href="#ae2c9749016fe3762f7e18472ad902ec0">mpv_render_context</a> *ctx, <a class="el" href="structmpv__render__param.html">mpv_render_param</a> param)</td></tr>
<tr class="separator:aa35d7678d61a6e5cc01b9670e2f0eccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d400a7aa5b865545acb5579fa651f7" id="r_ad5d400a7aa5b865545acb5579fa651f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="client_8h.html#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5d400a7aa5b865545acb5579fa651f7">mpv_render_context_set_update_callback</a> (<a class="el" href="#ae2c9749016fe3762f7e18472ad902ec0">mpv_render_context</a> *ctx, <a class="el" href="#aa976582e31273bcea01cd6d862a9a332">mpv_render_update_fn</a> callback, void *callback_ctx)</td></tr>
<tr class="separator:ad5d400a7aa5b865545acb5579fa651f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52a5374695fa06f98e92b5eb0538e98" id="r_af52a5374695fa06f98e92b5eb0538e98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="client_8h.html#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af52a5374695fa06f98e92b5eb0538e98">mpv_render_context_update</a> (<a class="el" href="#ae2c9749016fe3762f7e18472ad902ec0">mpv_render_context</a> *ctx)</td></tr>
<tr class="separator:af52a5374695fa06f98e92b5eb0538e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac60a37eba7ff4e48613ecde542ea62c7" id="r_ac60a37eba7ff4e48613ecde542ea62c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="client_8h.html#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac60a37eba7ff4e48613ecde542ea62c7">mpv_render_context_render</a> (<a class="el" href="#ae2c9749016fe3762f7e18472ad902ec0">mpv_render_context</a> *ctx, <a class="el" href="structmpv__render__param.html">mpv_render_param</a> *params)</td></tr>
<tr class="separator:ac60a37eba7ff4e48613ecde542ea62c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad92439f8eb565f006cb3982aa88ff095" id="r_ad92439f8eb565f006cb3982aa88ff095"><td class="memItemLeft" align="right" valign="top"><a class="el" href="client_8h.html#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad92439f8eb565f006cb3982aa88ff095">mpv_render_context_report_swap</a> (<a class="el" href="#ae2c9749016fe3762f7e18472ad902ec0">mpv_render_context</a> *ctx)</td></tr>
<tr class="separator:ad92439f8eb565f006cb3982aa88ff095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3cb5f89b0b579886317de4b0c6fe1a8" id="r_af3cb5f89b0b579886317de4b0c6fe1a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="client_8h.html#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3cb5f89b0b579886317de4b0c6fe1a8">mpv_render_context_free</a> (<a class="el" href="#ae2c9749016fe3762f7e18472ad902ec0">mpv_render_context</a> *ctx)</td></tr>
<tr class="separator:af3cb5f89b0b579886317de4b0c6fe1a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">宏定义说明</h2>
<a id="a6d8784066f41f06bd29406d3f3dd25de" name="a6d8784066f41f06bd29406d3f3dd25de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d8784066f41f06bd29406d3f3dd25de">&#9670;&#160;</a></span>MPV_RENDER_API_TYPE_OPENGL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MPV_RENDER_API_TYPE_OPENGL&#160;&#160;&#160;&quot;opengl&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Predefined values for MPV_RENDER_PARAM_API_TYPE. </p>

<p class="definition">在文件 <a class="el" href="render_8h_source.html">render.h</a> 第 <a class="el" href="render_8h_source.html#l00467">467</a> 行定义.</p>

</div>
</div>
<a id="a6bebdcbfd587ac3e17477d09ecc5c683" name="a6bebdcbfd587ac3e17477d09ecc5c683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bebdcbfd587ac3e17477d09ecc5c683">&#9670;&#160;</a></span>MPV_RENDER_API_TYPE_SW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MPV_RENDER_API_TYPE_SW&#160;&#160;&#160;&quot;sw&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">在文件 <a class="el" href="render_8h_source.html">render.h</a> 第 <a class="el" href="render_8h_source.html#l00469">469</a> 行定义.</p>

</div>
</div>
<a id="a64dcaec756f2b70f492bf254af3d0ec9" name="a64dcaec756f2b70f492bf254af3d0ec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64dcaec756f2b70f492bf254af3d0ec9">&#9670;&#160;</a></span>MPV_RENDER_PARAM_DRM_OSD_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MPV_RENDER_PARAM_DRM_OSD_SIZE&#160;&#160;&#160;<a class="el" href="#ac10cb1981663e694c377824212ef3ee0a41507e24190dd71b62517a40f9df10ff">MPV_RENDER_PARAM_DRM_DRAW_SURFACE_SIZE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For backwards compatibility with the old naming of MPV_RENDER_PARAM_DRM_DRAW_SURFACE_SIZE </p>

<p class="definition">在文件 <a class="el" href="render_8h_source.html">render.h</a> 第 <a class="el" href="render_8h_source.html#l00430">430</a> 行定义.</p>

</div>
</div>
<h2 class="groupheader">类型定义说明</h2>
<a id="ae2c9749016fe3762f7e18472ad902ec0" name="ae2c9749016fe3762f7e18472ad902ec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2c9749016fe3762f7e18472ad902ec0">&#9670;&#160;</a></span>mpv_render_context</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="#ae2c9749016fe3762f7e18472ad902ec0">mpv_render_context</a> <a class="el" href="#ae2c9749016fe3762f7e18472ad902ec0">mpv_render_context</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<h2><a class="anchor" id="autotoc_md11"></a>
Overview</h2>
<p>This API can be used to make mpv render using supported graphic APIs (such as OpenGL). It can be used to handle video display.</p>
<p>The renderer needs to be created with <a class="el" href="#a6326414507775cef9b21b5bbee1553d8">mpv_render_context_create()</a> before you start playback (or otherwise cause a VO to be created). Then (with most backends) <a class="el" href="#ac60a37eba7ff4e48613ecde542ea62c7">mpv_render_context_render()</a> can be used to explicitly render the current video frame. Use <a class="el" href="#ad5d400a7aa5b865545acb5579fa651f7">mpv_render_context_set_update_callback()</a> to get notified when there is a new frame to draw.</p>
<p>Preferably rendering should be done in a separate thread. If you call normal mpv API functions on the renderer thread, deadlocks can result (these are made non-fatal with timeouts, but user experience will obviously suffer). See "Threading" section below.</p>
<p>You can output and embed video without this API by setting the mpv "wid" option to a native window handle (see "Embedding the video window" section in the <a class="el" href="client_8h.html">client.h</a> header). In general, using the render API is recommended, because window embedding can cause various issues, especially with GUI toolkits and certain platforms.</p>
<h2><a class="anchor" id="autotoc_md12"></a>
Supported backends</h2>
<p>OpenGL: via MPV_RENDER_API_TYPE_OPENGL, see <a class="el" href="render__gl_8h.html">render_gl.h</a> header. Software: via MPV_RENDER_API_TYPE_SW, see section "Software renderer"</p>
<h2><a class="anchor" id="autotoc_md13"></a>
Threading</h2>
<p>You are recommended to do rendering on a separate thread than normal mpv use.</p>
<p>The mpv_render_* functions can be called from any thread, under the following conditions:</p><ul>
<li>only one of the mpv_render_* functions can be called at the same time (unless they belong to different mpv cores created by <a class="el" href="client_8h.html#acabb8d28abfb2614024eaa58a4de36e8">mpv_create()</a>)</li>
<li>never can be called from within the callbacks set with <a class="el" href="client_8h.html#a54b24fa9076b9c0ca5f988709d20e736">mpv_set_wakeup_callback()</a> or <a class="el" href="#ad5d400a7aa5b865545acb5579fa651f7">mpv_render_context_set_update_callback()</a></li>
<li>if the OpenGL backend is used, for all functions the OpenGL context must be "current" in the calling thread, and it must be the same OpenGL context as the mpv_render_context was created with. Otherwise, undefined behavior will occur.</li>
<li>the thread does not call mpv API functions other than the mpv_render_* functions, except APIs which are declared as safe (see below). Likewise, there must be no lock or wait dependency from the render thread to a thread using other mpv functions. Basically, the situation that your render thread waits for a "not safe" mpv API function to return must not happen. If you ignore this requirement, deadlocks can happen, which are made non-fatal with timeouts; then playback quality will be degraded, and the message <a class="el" href="#ac60a37eba7ff4e48613ecde542ea62c7">mpv_render_context_render()</a> not being called or stuck. is logged. If you set MPV_RENDER_PARAM_ADVANCED_CONTROL, you promise that this won't happen, and must absolutely guarantee it, or a real deadlock will freeze the mpv core thread forever.</li>
</ul>
<p>mpv functions which are safe to call from a render thread are:</p><ul>
<li>functions marked with "Safe to be called from mpv render API threads."</li>
<li><a class="el" href="client_8h.html">client.h</a> functions which don't have an explicit or implicit mpv_handle parameter</li>
<li>mpv_render_* functions; but only for the same mpv_render_context pointer. If the pointer is different, <a class="el" href="#af3cb5f89b0b579886317de4b0c6fe1a8">mpv_render_context_free()</a> is not safe. (The reason is that if MPV_RENDER_PARAM_ADVANCED_CONTROL is set, it may have to process still queued requests from the core, which it can do only for the current context, while requests for other contexts would deadlock. Also, it may have to wait and block for the core to terminate the video chain to make sure no resources are used after context destruction.)</li>
<li>if the mpv_handle parameter refers to a different mpv core than the one you're rendering for (very obscure, but allowed)</li>
</ul>
<p>Note about old mpv version: </p><pre class="fragment"> Before API version 1.105 (basically in mpv 0.29.x), simply enabling
 MPV_RENDER_PARAM_ADVANCED_CONTROL could cause deadlock issues. This can
 be worked around by setting the "vd-lavc-dr" option to "no".
 In addition, you were required to call all mpv_render*() API functions
 from the same thread on which mpv_render_context_create() was originally
 run (for the same the mpv_render_context). Not honoring it led to UB
 (deadlocks, use of invalid mp_thread handles), even if you moved your GL
 context to a different thread correctly.
 These problems were addressed in API version 1.105 (mpv 0.30.0).
</pre> <h2><a class="anchor" id="autotoc_md14"></a>
Context and handle lifecycle</h2>
<p>Video initialization will fail if the render context was not initialized yet (with <a class="el" href="#a6326414507775cef9b21b5bbee1553d8">mpv_render_context_create()</a>), or it will revert to a VO that creates its own window.</p>
<p>Currently, there can be only 1 mpv_render_context at a time per mpv core.</p>
<p>Calling <a class="el" href="#af3cb5f89b0b579886317de4b0c6fe1a8">mpv_render_context_free()</a> while a VO is using the render context is active will disable video.</p>
<p>You must free the context with <a class="el" href="#af3cb5f89b0b579886317de4b0c6fe1a8">mpv_render_context_free()</a> before the mpv core is destroyed. If this doesn't happen, undefined behavior will result.</p>
<h2><a class="anchor" id="autotoc_md15"></a>
Software renderer</h2>
<p>MPV_RENDER_API_TYPE_SW provides an extremely simple (but slow) renderer to memory surfaces. You probably don't want to use this. Use other render API types, or other methods of video embedding.</p>
<p>Use <a class="el" href="#a6326414507775cef9b21b5bbee1553d8">mpv_render_context_create()</a> with MPV_RENDER_PARAM_API_TYPE set to MPV_RENDER_API_TYPE_SW.</p>
<p>Call <a class="el" href="#ac60a37eba7ff4e48613ecde542ea62c7">mpv_render_context_render()</a> with various MPV_RENDER_PARAM_SW_* fields to render the video frame to an in-memory surface. The following fields are required: MPV_RENDER_PARAM_SW_SIZE, MPV_RENDER_PARAM_SW_FORMAT, MPV_RENDER_PARAM_SW_STRIDE, MPV_RENDER_PARAM_SW_POINTER.</p>
<p>This method of rendering is very slow, because everything, including color conversion, scaling, and OSD rendering, is done on the CPU, single-threaded. In particular, large video or display sizes, as well as presence of OSD or subtitles can make it too slow for realtime. As with other software rendering VOs, setting "sw-fast" may help. Enabling or disabling zimg may help, depending on the platform.</p>
<p>In addition, certain multimedia job creation measures like HDR may not work properly, and will have to be manually handled by for example inserting filters.</p>
<p>This API is not really suitable to extract individual frames from video etc. (basically non-playback uses) - there are better libraries for this. It can be used this way, but it may be clunky and tricky.</p>
<p>Further notes:</p><ul>
<li>MPV_RENDER_PARAM_FLIP_Y is currently ignored (unsupported)</li>
<li>MPV_RENDER_PARAM_DEPTH is ignored (meaningless) Opaque context, returned by <a class="el" href="#a6326414507775cef9b21b5bbee1553d8">mpv_render_context_create()</a>. </li>
</ul>

<p class="definition">在文件 <a class="el" href="render_8h_source.html">render.h</a> 第 <a class="el" href="render_8h_source.html#l00163">163</a> 行定义.</p>

</div>
</div>
<a id="a77f83d1161ed49a29c6db4782a6a02ee" name="a77f83d1161ed49a29c6db4782a6a02ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77f83d1161ed49a29c6db4782a6a02ee">&#9670;&#160;</a></span>mpv_render_context_flag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="#ade728e3f6e75aab0259e51991968e481">mpv_render_update_flag</a> <a class="el" href="#a77f83d1161ed49a29c6db4782a6a02ee">mpv_render_context_flag</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags returned by <a class="el" href="#af52a5374695fa06f98e92b5eb0538e98">mpv_render_context_update()</a>. Each value represents a bit in the function's return value. </p>

</div>
</div>
<a id="aebaf6c6904d34ebbe6dc228c5d4cf443" name="aebaf6c6904d34ebbe6dc228c5d4cf443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebaf6c6904d34ebbe6dc228c5d4cf443">&#9670;&#160;</a></span>mpv_render_frame_info</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct mpv_render_frame_info mpv_render_frame_info</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Information about the next video frame that will be rendered. Can be retrieved with MPV_RENDER_PARAM_NEXT_FRAME_INFO. </p>

</div>
</div>
<a id="a93d7b5c5b6762484ea191860a5fdb135" name="a93d7b5c5b6762484ea191860a5fdb135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93d7b5c5b6762484ea191860a5fdb135">&#9670;&#160;</a></span>mpv_render_frame_info_flag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="#a3706d2f8d449ca817136c993d2e6e015">mpv_render_frame_info_flag</a> <a class="el" href="#a3706d2f8d449ca817136c993d2e6e015">mpv_render_frame_info_flag</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags used in <a class="el" href="structmpv__render__frame__info.html#a64ad3a4697dbad99f8edef86472b122a">mpv_render_frame_info.flags</a>. Each value represents a bit in it. </p>

</div>
</div>
<a id="ab9bff7a3d8ff3e2a992282b8f736571e" name="ab9bff7a3d8ff3e2a992282b8f736571e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9bff7a3d8ff3e2a992282b8f736571e">&#9670;&#160;</a></span>mpv_render_param</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct mpv_render_param mpv_render_param</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used to pass arbitrary parameters to some mpv_render_* functions. The meaning of the data parameter is determined by the type, and each MPV_RENDER_PARAM_* documents what type the value must point to.</p>
<p>Each value documents the required data type as the pointer you cast to void* and set on <a class="el" href="structmpv__render__param.html#a0a3baab5cfdedcb3f669f3fcfa74e7f0">mpv_render_param.data</a>. For example, if MPV_RENDER_PARAM_FOO documents the type as Something* , then the code should look like this:</p>
<p>Something foo = {...}; <a class="el" href="structmpv__render__param.html">mpv_render_param</a> param; param.type = MPV_RENDER_PARAM_FOO; param.data = &amp; foo;</p>
<p>Normally, the data field points to exactly 1 object. If the type is char*, it points to a 0-terminated string.</p>
<p>In all cases (unless documented otherwise) the pointers need to remain valid during the call only. Unless otherwise documented, the API functions will not write to the params array or any data pointed to it.</p>
<p>As a convention, parameter arrays are always terminated by type==0. There is no specific order of the parameters required. The order of the 2 fields in this struct is guaranteed (even after ABI changes). </p>

</div>
</div>
<a id="a0b915c951c37a8a80936e25b7d2e7779" name="a0b915c951c37a8a80936e25b7d2e7779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b915c951c37a8a80936e25b7d2e7779">&#9670;&#160;</a></span>mpv_render_param_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="#ac10cb1981663e694c377824212ef3ee0">mpv_render_param_type</a> <a class="el" href="#ac10cb1981663e694c377824212ef3ee0">mpv_render_param_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters for <a class="el" href="structmpv__render__param.html">mpv_render_param</a> (which is used in a few places such as <a class="el" href="#a6326414507775cef9b21b5bbee1553d8">mpv_render_context_create()</a>.</p>
<p>Also see <a class="el" href="structmpv__render__param.html">mpv_render_param</a> for conventions and how to use it. </p>

</div>
</div>
<a id="aa976582e31273bcea01cd6d862a9a332" name="aa976582e31273bcea01cd6d862a9a332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa976582e31273bcea01cd6d862a9a332">&#9670;&#160;</a></span>mpv_render_update_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* mpv_render_update_fn) (void *cb_ctx)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">在文件 <a class="el" href="render_8h_source.html">render.h</a> 第 <a class="el" href="render_8h_source.html#l00615">615</a> 行定义.</p>

</div>
</div>
<h2 class="groupheader">枚举类型说明</h2>
<a id="a3706d2f8d449ca817136c993d2e6e015" name="a3706d2f8d449ca817136c993d2e6e015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3706d2f8d449ca817136c993d2e6e015">&#9670;&#160;</a></span>mpv_render_frame_info_flag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a3706d2f8d449ca817136c993d2e6e015">mpv_render_frame_info_flag</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags used in <a class="el" href="structmpv__render__frame__info.html#a64ad3a4697dbad99f8edef86472b122a">mpv_render_frame_info.flags</a>. Each value represents a bit in it. </p>
<table class="fieldtable">
<tr><th colspan="2">枚举值</th></tr><tr><td class="fieldname"><a id="a3706d2f8d449ca817136c993d2e6e015ad9b24f90e1f5b0c22abf7657e1425acf" name="a3706d2f8d449ca817136c993d2e6e015ad9b24f90e1f5b0c22abf7657e1425acf"></a>MPV_RENDER_FRAME_INFO_PRESENT&#160;</td><td class="fielddoc"><p>Set if there is actually a next frame. If unset, there is no next frame yet, and other flags and fields that require a frame to be queued will be unset.</p>
<p>This is set for <em>any</em> kind of frame, even for redraw requests.</p>
<p>Note that when this is unset, it simply means no new frame was decoded/queued yet, not necessarily that the end of the video was reached. A new frame can be queued after some time.</p>
<p>If the return value of <a class="el" href="#ac60a37eba7ff4e48613ecde542ea62c7">mpv_render_context_render()</a> had the MPV_RENDER_UPDATE_FRAME flag set, this flag will usually be set as well, unless the frame is rendered, or discarded by other asynchronous events. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3706d2f8d449ca817136c993d2e6e015ad0e0815285dc8cc5d7aa96db319e25f8" name="a3706d2f8d449ca817136c993d2e6e015ad0e0815285dc8cc5d7aa96db319e25f8"></a>MPV_RENDER_FRAME_INFO_REDRAW&#160;</td><td class="fielddoc"><p>If set, the frame is not an actual new video frame, but a redraw request. For example if the video is paused, and an option that affects video rendering was changed (or any other reason), an update request can be issued and this flag will be set.</p>
<p>Typically, redraw frames will not be subject to video timing.</p>
<p>Implies MPV_RENDER_FRAME_INFO_PRESENT. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3706d2f8d449ca817136c993d2e6e015a3d748e2e67b49defc57db3715bf98306" name="a3706d2f8d449ca817136c993d2e6e015a3d748e2e67b49defc57db3715bf98306"></a>MPV_RENDER_FRAME_INFO_REPEAT&#160;</td><td class="fielddoc"><p>If set, this is supposed to reproduce the previous frame perfectly. This is usually used for certain "video-sync" options ("display-..." modes). Typically the renderer will blit the video from a FBO. Unset otherwise.</p>
<p>Implies MPV_RENDER_FRAME_INFO_PRESENT. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3706d2f8d449ca817136c993d2e6e015a5a06dde0f579f92419879ed2c3996c0d" name="a3706d2f8d449ca817136c993d2e6e015a5a06dde0f579f92419879ed2c3996c0d"></a>MPV_RENDER_FRAME_INFO_BLOCK_VSYNC&#160;</td><td class="fielddoc"><p>If set, the player timing code expects that the user thread blocks on vsync (by either delaying the render call, or by making a call to <a class="el" href="#ad92439f8eb565f006cb3982aa88ff095">mpv_render_context_report_swap()</a> at vsync time).</p>
<p>Implies MPV_RENDER_FRAME_INFO_PRESENT. </p>
</td></tr>
</table>

<p class="definition">在文件 <a class="el" href="render_8h_source.html">render.h</a> 第 <a class="el" href="render_8h_source.html#l00474">474</a> 行定义.</p>

</div>
</div>
<a id="ac10cb1981663e694c377824212ef3ee0" name="ac10cb1981663e694c377824212ef3ee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac10cb1981663e694c377824212ef3ee0">&#9670;&#160;</a></span>mpv_render_param_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ac10cb1981663e694c377824212ef3ee0">mpv_render_param_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters for <a class="el" href="structmpv__render__param.html">mpv_render_param</a> (which is used in a few places such as <a class="el" href="#a6326414507775cef9b21b5bbee1553d8">mpv_render_context_create()</a>.</p>
<p>Also see <a class="el" href="structmpv__render__param.html">mpv_render_param</a> for conventions and how to use it. </p>
<table class="fieldtable">
<tr><th colspan="2">枚举值</th></tr><tr><td class="fieldname"><a id="ac10cb1981663e694c377824212ef3ee0af546b92d3d931ef18ddab987940ab15f" name="ac10cb1981663e694c377824212ef3ee0af546b92d3d931ef18ddab987940ab15f"></a>MPV_RENDER_PARAM_INVALID&#160;</td><td class="fielddoc"><p>Not a valid value, but also used to terminate a params array. Its value is always guaranteed to be 0 (even if the ABI changes in the future). </p>
</td></tr>
<tr><td class="fieldname"><a id="ac10cb1981663e694c377824212ef3ee0a5764b1f4daccc7ec76d04b95299f55aa" name="ac10cb1981663e694c377824212ef3ee0a5764b1f4daccc7ec76d04b95299f55aa"></a>MPV_RENDER_PARAM_API_TYPE&#160;</td><td class="fielddoc"><p>The render API to use. Valid for <a class="el" href="#a6326414507775cef9b21b5bbee1553d8">mpv_render_context_create()</a>.</p>
<p>Type: char*</p>
<p>Defined APIs:</p>
<p>MPV_RENDER_API_TYPE_OPENGL: OpenGL desktop 2.1 or later (preferably core profile compatible to OpenGL 3.2), or OpenGLES 2.0 or later. Providing MPV_RENDER_PARAM_OPENGL_INIT_PARAMS is required. It is expected that an OpenGL context is valid and "current" when calling mpv_render_* functions (unless specified otherwise). It must be the same context for the same mpv_render_context. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac10cb1981663e694c377824212ef3ee0a1821fd6ee9b1f12f30e73368bd66b2b3" name="ac10cb1981663e694c377824212ef3ee0a1821fd6ee9b1f12f30e73368bd66b2b3"></a>MPV_RENDER_PARAM_OPENGL_INIT_PARAMS&#160;</td><td class="fielddoc"><p>Required parameters for initializing the OpenGL renderer. Valid for <a class="el" href="#a6326414507775cef9b21b5bbee1553d8">mpv_render_context_create()</a>. Type: mpv_opengl_init_params* </p>
</td></tr>
<tr><td class="fieldname"><a id="ac10cb1981663e694c377824212ef3ee0a993215484355e7eddf30dff9dca37c27" name="ac10cb1981663e694c377824212ef3ee0a993215484355e7eddf30dff9dca37c27"></a>MPV_RENDER_PARAM_OPENGL_FBO&#160;</td><td class="fielddoc"><p>Describes a GL render target. Valid for <a class="el" href="#ac60a37eba7ff4e48613ecde542ea62c7">mpv_render_context_render()</a>. Type: mpv_opengl_fbo* </p>
</td></tr>
<tr><td class="fieldname"><a id="ac10cb1981663e694c377824212ef3ee0aead5b92c56ac4f38c5585547bd01d30b" name="ac10cb1981663e694c377824212ef3ee0aead5b92c56ac4f38c5585547bd01d30b"></a>MPV_RENDER_PARAM_FLIP_Y&#160;</td><td class="fielddoc"><p>Control flipped rendering. Valid for <a class="el" href="#ac60a37eba7ff4e48613ecde542ea62c7">mpv_render_context_render()</a>. Type: int* If the value is set to 0, render normally. Otherwise, render it flipped, which is needed e.g. when rendering to an OpenGL default framebuffer (which has a flipped coordinate system). </p>
</td></tr>
<tr><td class="fieldname"><a id="ac10cb1981663e694c377824212ef3ee0a89ba84bc2924f868b471031fc1449c55" name="ac10cb1981663e694c377824212ef3ee0a89ba84bc2924f868b471031fc1449c55"></a>MPV_RENDER_PARAM_DEPTH&#160;</td><td class="fielddoc"><p>Control surface depth. Valid for <a class="el" href="#ac60a37eba7ff4e48613ecde542ea62c7">mpv_render_context_render()</a>. Type: int* This implies the depth of the surface passed to the render function in bits per channel. If omitted or set to 0, the renderer will assume 8. Typically used to control dithering. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac10cb1981663e694c377824212ef3ee0ae42158d5e877a4509dd4ed22297a37b3" name="ac10cb1981663e694c377824212ef3ee0ae42158d5e877a4509dd4ed22297a37b3"></a>MPV_RENDER_PARAM_ICC_PROFILE&#160;</td><td class="fielddoc"><p>ICC profile blob. Valid for <a class="el" href="#a817e67dc0a7a56c13911bbe01627aaaf">mpv_render_context_set_parameter()</a>. Type: mpv_byte_array* Set an ICC profile for use with the "icc-profile-auto" option. (If the option is not enabled, the ICC data will not be used.) </p>
</td></tr>
<tr><td class="fieldname"><a id="ac10cb1981663e694c377824212ef3ee0a7bdb36791bf4200ceaf2ffe1a31e29dc" name="ac10cb1981663e694c377824212ef3ee0a7bdb36791bf4200ceaf2ffe1a31e29dc"></a>MPV_RENDER_PARAM_AMBIENT_LIGHT&#160;</td><td class="fielddoc"><p>Ambient light in lux. Valid for <a class="el" href="#a817e67dc0a7a56c13911bbe01627aaaf">mpv_render_context_set_parameter()</a>. Type: int* This can be used for automatic gamma correction. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac10cb1981663e694c377824212ef3ee0abdcd4db20a148c056f0868ad3a3d4e36" name="ac10cb1981663e694c377824212ef3ee0abdcd4db20a148c056f0868ad3a3d4e36"></a>MPV_RENDER_PARAM_X11_DISPLAY&#160;</td><td class="fielddoc"><p>X11 Display, sometimes used for hwdec. Valid for <a class="el" href="#a6326414507775cef9b21b5bbee1553d8">mpv_render_context_create()</a>. The Display must stay valid for the lifetime of the mpv_render_context. Type: Display* </p>
</td></tr>
<tr><td class="fieldname"><a id="ac10cb1981663e694c377824212ef3ee0aa9f339165fd8ab3cdf0bfe2242040111" name="ac10cb1981663e694c377824212ef3ee0aa9f339165fd8ab3cdf0bfe2242040111"></a>MPV_RENDER_PARAM_WL_DISPLAY&#160;</td><td class="fielddoc"><p>Wayland display, sometimes used for hwdec. Valid for <a class="el" href="#a6326414507775cef9b21b5bbee1553d8">mpv_render_context_create()</a>. The wl_display must stay valid for the lifetime of the mpv_render_context. Type: struct wl_display* </p>
</td></tr>
<tr><td class="fieldname"><a id="ac10cb1981663e694c377824212ef3ee0a048ff8b9e379ed5e4b35757ab6d354b3" name="ac10cb1981663e694c377824212ef3ee0a048ff8b9e379ed5e4b35757ab6d354b3"></a>MPV_RENDER_PARAM_ADVANCED_CONTROL&#160;</td><td class="fielddoc"><p>Better control about rendering and enabling some advanced features. Valid for <a class="el" href="#a6326414507775cef9b21b5bbee1553d8">mpv_render_context_create()</a>.</p>
<p>This conflates multiple requirements the API user promises to abide if this option is enabled:</p>
<ul>
<li>The API user's render thread, which is calling the mpv_render_*() functions, never waits for the core. Otherwise deadlocks can happen. See "Threading" section.</li>
<li>The callback set with <a class="el" href="#ad5d400a7aa5b865545acb5579fa651f7">mpv_render_context_set_update_callback()</a> can now be called even if there is no new frame. The API user should call the <a class="el" href="#af52a5374695fa06f98e92b5eb0538e98">mpv_render_context_update()</a> function, and interpret the return value for whether a new frame should be rendered.</li>
<li>Correct functionality is impossible if the update callback is not set, or not set soon enough after <a class="el" href="#a6326414507775cef9b21b5bbee1553d8">mpv_render_context_create()</a> (the core can block while waiting for you to call <a class="el" href="#af52a5374695fa06f98e92b5eb0538e98">mpv_render_context_update()</a>, and if the update callback is not correctly set, it will deadlock, or block for too long).</li>
</ul>
<p>In general, setting this option will enable the following features (and possibly more):</p>
<ul>
<li>"Direct rendering", which means the player decodes directly to a texture, which saves a copy per video frame ("vd-lavc-dr" option needs to be enabled, and the rendering backend as well as the underlying GPU API/driver needs to have support for it).</li>
<li>Rendering screenshots with the GPU API if supported by the backend (instead of using a suboptimal software fallback via libswscale).</li>
</ul>
<p>Warning: do not just add this without reading the "Threading" section above, and then wondering that deadlocks happen. The requirements are tricky. But also note that even if advanced control is disabled, not adhering to the rules will lead to playback problems. Enabling advanced controls simply makes violating these rules fatal.</p>
<p>Type: int*: 0 for disable (default), 1 for enable </p>
</td></tr>
<tr><td class="fieldname"><a id="ac10cb1981663e694c377824212ef3ee0ae7f1332a83b97b76915d43c071ec2b16" name="ac10cb1981663e694c377824212ef3ee0ae7f1332a83b97b76915d43c071ec2b16"></a>MPV_RENDER_PARAM_NEXT_FRAME_INFO&#160;</td><td class="fielddoc"><p>Return information about the next frame to render. Valid for <a class="el" href="#aa35d7678d61a6e5cc01b9670e2f0eccd">mpv_render_context_get_info()</a>.</p>
<p>Type: mpv_render_frame_info*</p>
<p>It strictly returns information about the <em>next</em> frame. The implication is that e.g. <a class="el" href="#af52a5374695fa06f98e92b5eb0538e98">mpv_render_context_update()</a>'s return value will have MPV_RENDER_UPDATE_FRAME set, and the user is supposed to call <a class="el" href="#ac60a37eba7ff4e48613ecde542ea62c7">mpv_render_context_render()</a>. If there is no next frame, then the return value will have is_valid set to 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac10cb1981663e694c377824212ef3ee0a6a778d6edb83567c544046263c970ee7" name="ac10cb1981663e694c377824212ef3ee0a6a778d6edb83567c544046263c970ee7"></a>MPV_RENDER_PARAM_BLOCK_FOR_TARGET_TIME&#160;</td><td class="fielddoc"><p>Enable or disable video timing. Valid for <a class="el" href="#ac60a37eba7ff4e48613ecde542ea62c7">mpv_render_context_render()</a>.</p>
<p>Type: int*: 0 for disable, 1 for enable (default)</p>
<p>When video is timed to audio, the player attempts to render video a bit ahead, and then do a blocking wait until the target display time is reached. This blocks <a class="el" href="#ac60a37eba7ff4e48613ecde542ea62c7">mpv_render_context_render()</a> for up to the amount specified with the "video-timing-offset" global option. You can set this parameter to 0 to disable this kind of waiting. If you do, it's recommended to use the target time value in <a class="el" href="structmpv__render__frame__info.html">mpv_render_frame_info</a> to wait yourself, or to set the "video-timing-offset" to 0 instead.</p>
<p>Disabling this without doing anything in addition will result in A/V sync being slightly off. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac10cb1981663e694c377824212ef3ee0a44e483a9b77c4e9ee5daee1a71b7dd14" name="ac10cb1981663e694c377824212ef3ee0a44e483a9b77c4e9ee5daee1a71b7dd14"></a>MPV_RENDER_PARAM_SKIP_RENDERING&#160;</td><td class="fielddoc"><p>Use to skip rendering in <a class="el" href="#ac60a37eba7ff4e48613ecde542ea62c7">mpv_render_context_render()</a>.</p>
<p>Type: int*: 0 for rendering (default), 1 for skipping</p>
<p>If this is set, you don't need to pass a target surface to the render function (and if you do, it's completely ignored). This can still call into the lower level APIs (i.e. if you use OpenGL, the OpenGL context must be set).</p>
<p>Be aware that the render API will consider this frame as having been rendered. All other normal rules also apply, for example about whether you have to call <a class="el" href="#ad92439f8eb565f006cb3982aa88ff095">mpv_render_context_report_swap()</a>. It also does timing in the same way. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac10cb1981663e694c377824212ef3ee0a238c4273b69dcd60c6b875cfd3fc41a1" name="ac10cb1981663e694c377824212ef3ee0a238c4273b69dcd60c6b875cfd3fc41a1"></a>MPV_RENDER_PARAM_DRM_DISPLAY&#160;</td><td class="fielddoc"><p>Deprecated. Not supported. Use MPV_RENDER_PARAM_DRM_DISPLAY_V2 instead. Type : struct mpv_opengl_drm_params* </p>
</td></tr>
<tr><td class="fieldname"><a id="ac10cb1981663e694c377824212ef3ee0a41507e24190dd71b62517a40f9df10ff" name="ac10cb1981663e694c377824212ef3ee0a41507e24190dd71b62517a40f9df10ff"></a>MPV_RENDER_PARAM_DRM_DRAW_SURFACE_SIZE&#160;</td><td class="fielddoc"><p>DRM draw surface size, contains draw surface dimensions. Valid for <a class="el" href="#a6326414507775cef9b21b5bbee1553d8">mpv_render_context_create()</a>. Type : struct mpv_opengl_drm_draw_surface_size* </p>
</td></tr>
<tr><td class="fieldname"><a id="ac10cb1981663e694c377824212ef3ee0a7c172f2aeb1cb25c01bda0e482c41b66" name="ac10cb1981663e694c377824212ef3ee0a7c172f2aeb1cb25c01bda0e482c41b66"></a>MPV_RENDER_PARAM_DRM_DISPLAY_V2&#160;</td><td class="fielddoc"><p>DRM display, contains drm display handles. Valid for <a class="el" href="#a6326414507775cef9b21b5bbee1553d8">mpv_render_context_create()</a>. Type : struct mpv_opengl_drm_params_v2* </p>
</td></tr>
<tr><td class="fieldname"><a id="ac10cb1981663e694c377824212ef3ee0af1970a55f4e46d457d43d6f1a71fe552" name="ac10cb1981663e694c377824212ef3ee0af1970a55f4e46d457d43d6f1a71fe552"></a>MPV_RENDER_PARAM_SW_SIZE&#160;</td><td class="fielddoc"><p>MPV_RENDER_API_TYPE_SW only: rendering target surface size, mandatory. Valid for MPV_RENDER_API_TYPE_SW &amp; <a class="el" href="#ac60a37eba7ff4e48613ecde542ea62c7">mpv_render_context_render()</a>. Type: int[2] (e.g.: int s[2] = {w, h}; param.data = &amp;s[0];)</p>
<p>The video frame is transformed as with other VOs. Typically, this means the video gets scaled and black bars are added if the video size or aspect ratio mismatches with the target size. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac10cb1981663e694c377824212ef3ee0a573360e4ab75761e517f2745d2a13a07" name="ac10cb1981663e694c377824212ef3ee0a573360e4ab75761e517f2745d2a13a07"></a>MPV_RENDER_PARAM_SW_FORMAT&#160;</td><td class="fielddoc"><p>MPV_RENDER_API_TYPE_SW only: rendering target surface pixel format, mandatory. Valid for MPV_RENDER_API_TYPE_SW &amp; <a class="el" href="#ac60a37eba7ff4e48613ecde542ea62c7">mpv_render_context_render()</a>. Type: char* (e.g.: char *f = "rgb0"; param.data = f;)</p>
<p>Valid values are: "rgb0", "bgr0", "0bgr", "0rgb" 4 bytes per pixel RGB, 1 byte (8 bit) per component, component bytes with increasing address from left to right (e.g. "rgb0" has r at address 0), the "0" component contains uninitialized garbage (often the value 0, but not necessarily; the bad naming is inherited from FFmpeg) Pixel alignment size: 4 bytes "rgb24" 3 bytes per pixel RGB. This is strongly discouraged because it is very slow. Pixel alignment size: 1 bytes other The API may accept other pixel formats, using mpv internal format names, as long as it's internally marked as RGB, has exactly 1 plane, and is supported as conversion output. It is not a good idea to rely on any of these. Their semantics and handling could change. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac10cb1981663e694c377824212ef3ee0a066750dd977606998eb66d9b2e87da0a" name="ac10cb1981663e694c377824212ef3ee0a066750dd977606998eb66d9b2e87da0a"></a>MPV_RENDER_PARAM_SW_STRIDE&#160;</td><td class="fielddoc"><p>MPV_RENDER_API_TYPE_SW only: rendering target surface bytes per line, mandatory. Valid for MPV_RENDER_API_TYPE_SW &amp; <a class="el" href="#ac60a37eba7ff4e48613ecde542ea62c7">mpv_render_context_render()</a>. Type: size_t*</p>
<p>This is the number of bytes between a pixel (x, y) and (x, y + 1) on the target surface. It must be a multiple of the pixel size, and have space for the surface width as specified by MPV_RENDER_PARAM_SW_SIZE.</p>
<p>Both stride and pointer value should be a multiple of 64 to facilitate fast SIMD operation. Lower alignment might trigger slower code paths, and in the worst case, will copy the entire target frame. If mpv is built with zimg (and zimg is not disabled), the performance impact might be less. In either cases, the pointer and stride must be aligned at least to the pixel alignment size. Otherwise, crashes and undefined behavior is possible on platforms which do not support unaligned accesses (either through normal memory access or aligned SIMD memory access instructions). </p>
</td></tr>
<tr><td class="fieldname"><a id="ac10cb1981663e694c377824212ef3ee0a81f0e9c7bd7868dbac532be9de6c5632" name="ac10cb1981663e694c377824212ef3ee0a81f0e9c7bd7868dbac532be9de6c5632"></a>MPV_RENDER_PARAM_SW_POINTER&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">在文件 <a class="el" href="render_8h_source.html">render.h</a> 第 <a class="el" href="render_8h_source.html#l00171">171</a> 行定义.</p>

</div>
</div>
<a id="ade728e3f6e75aab0259e51991968e481" name="ade728e3f6e75aab0259e51991968e481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade728e3f6e75aab0259e51991968e481">&#9670;&#160;</a></span>mpv_render_update_flag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ade728e3f6e75aab0259e51991968e481">mpv_render_update_flag</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags returned by <a class="el" href="#af52a5374695fa06f98e92b5eb0538e98">mpv_render_context_update()</a>. Each value represents a bit in the function's return value. </p>
<table class="fieldtable">
<tr><th colspan="2">枚举值</th></tr><tr><td class="fieldname"><a id="ade728e3f6e75aab0259e51991968e481a2dcb3d9854e2a3987024c87b8e9eadc0" name="ade728e3f6e75aab0259e51991968e481a2dcb3d9854e2a3987024c87b8e9eadc0"></a>MPV_RENDER_UPDATE_FRAME&#160;</td><td class="fielddoc"><p>A new video frame must be rendered. <a class="el" href="#ac60a37eba7ff4e48613ecde542ea62c7">mpv_render_context_render()</a> must be called. </p>
</td></tr>
</table>

<p class="definition">在文件 <a class="el" href="render_8h_source.html">render.h</a> 第 <a class="el" href="render_8h_source.html#l00666">666</a> 行定义.</p>

</div>
</div>
<h2 class="groupheader">函数说明</h2>
<a id="a6326414507775cef9b21b5bbee1553d8" name="a6326414507775cef9b21b5bbee1553d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6326414507775cef9b21b5bbee1553d8">&#9670;&#160;</a></span>mpv_render_context_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="client_8h.html#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int mpv_render_context_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae2c9749016fe3762f7e18472ad902ec0">mpv_render_context</a> **</td>          <td class="paramname"><span class="paramname"><em>res</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="client_8h.html#a93d313a21048fe10f1edd9b03e05d416">mpv_handle</a> *</td>          <td class="paramname"><span class="paramname"><em>mpv</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmpv__render__param.html">mpv_render_param</a> *</td>          <td class="paramname"><span class="paramname"><em>params</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the renderer state. Depending on the backend used, this will access the underlying GPU API and initialize its own objects.</p>
<p>You must free the context with <a class="el" href="#af3cb5f89b0b579886317de4b0c6fe1a8">mpv_render_context_free()</a>. Not doing so before the mpv core is destroyed may result in memory leaks or crashes.</p>
<p>Currently, only at most 1 context can exists per mpv core (it represents the main video output).</p>
<p>You should pass the following parameters:</p><ul>
<li>MPV_RENDER_PARAM_API_TYPE to select the underlying backend/GPU API.</li>
<li>Backend-specific init parameter, like MPV_RENDER_PARAM_OPENGL_INIT_PARAMS.</li>
<li>Setting MPV_RENDER_PARAM_ADVANCED_CONTROL and following its rules is strongly recommended.</li>
<li>If you want to use hwdec, possibly hwdec interop resources.</li>
</ul>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>set to the context (on success) or NULL (on failure). The value is never read and always overwritten. </td></tr>
    <tr><td class="paramname">mpv</td><td>handle used to get the core (the mpv_render_context won't depend on this specific handle, only the core referenced by it) </td></tr>
    <tr><td class="paramname">params</td><td>an array of parameters, terminated by type==0. It's left unspecified what happens with unknown parameters. At least MPV_RENDER_PARAM_API_TYPE is required, and most backends will require another backend-specific parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>error code, including but not limited to: MPV_ERROR_UNSUPPORTED: the OpenGL version is not supported (or required extensions are missing) MPV_ERROR_NOT_IMPLEMENTED: an unknown API type was provided, or support for the requested API was not built in the used mpv binary. MPV_ERROR_INVALID_PARAMETER: at least one of the provided parameters was not valid. </dd></dl>

</div>
</div>
<a id="af3cb5f89b0b579886317de4b0c6fe1a8" name="af3cb5f89b0b579886317de4b0c6fe1a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3cb5f89b0b579886317de4b0c6fe1a8">&#9670;&#160;</a></span>mpv_render_context_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="client_8h.html#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> void mpv_render_context_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae2c9749016fe3762f7e18472ad902ec0">mpv_render_context</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy the mpv renderer state.</p>
<p>If video is still active (e.g. a file playing), video will be disabled forcefully.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>a valid render context. After this function returns, this is not a valid pointer anymore. NULL is also allowed and does nothing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa35d7678d61a6e5cc01b9670e2f0eccd" name="aa35d7678d61a6e5cc01b9670e2f0eccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa35d7678d61a6e5cc01b9670e2f0eccd">&#9670;&#160;</a></span>mpv_render_context_get_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="client_8h.html#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int mpv_render_context_get_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae2c9749016fe3762f7e18472ad902ec0">mpv_render_context</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmpv__render__param.html">mpv_render_param</a></td>          <td class="paramname"><span class="paramname"><em>param</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve information from the render context. This is NOT a counterpart to <a class="el" href="#a817e67dc0a7a56c13911bbe01627aaaf">mpv_render_context_set_parameter()</a>, because you generally can't read parameters set with it, and this function is not meant for this purpose. Instead, this is for communicating information from the renderer back to the user. See mpv_render_param_type; entries which support this function explicitly mention it, and for other entries you can assume it will fail.</p>
<p>You pass param with param.type set and param.data pointing to a variable of the required data type. The function will then overwrite that variable with the returned value (at least on success).</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>a valid render context </td></tr>
    <tr><td class="paramname">param</td><td>the parameter type and data that should be retrieved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>error code. If a parameter could actually be retrieved, this returns success, otherwise an error code depending on the parameter type and situation. MPV_ERROR_NOT_IMPLEMENTED is used for unknown param.type, or if retrieving it is not supported. </dd></dl>

</div>
</div>
<a id="ac60a37eba7ff4e48613ecde542ea62c7" name="ac60a37eba7ff4e48613ecde542ea62c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac60a37eba7ff4e48613ecde542ea62c7">&#9670;&#160;</a></span>mpv_render_context_render()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="client_8h.html#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int mpv_render_context_render </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae2c9749016fe3762f7e18472ad902ec0">mpv_render_context</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmpv__render__param.html">mpv_render_param</a> *</td>          <td class="paramname"><span class="paramname"><em>params</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Render video.</p>
<p>Typically renders the video to a target surface provided via <a class="el" href="structmpv__render__param.html">mpv_render_param</a> (the details depend on the backend in use). Options like "panscan" are applied to determine which part of the video should be visible and how the video should be scaled. You can change these options at runtime by using the mpv property API.</p>
<p>The renderer will reconfigure itself every time the target surface configuration (such as size) is changed.</p>
<p>This function implicitly pulls a video frame from the internal queue and renders it. If no new frame is available, the previous frame is redrawn. The update callback set with <a class="el" href="#ad5d400a7aa5b865545acb5579fa651f7">mpv_render_context_set_update_callback()</a> notifies you when a new frame was added. The details potentially depend on the backends and the provided parameters.</p>
<p>Generally, mpv will invoke your update callback some time before the video frame should be shown, and then lets this function block until the supposed display time. This will limit your rendering to video FPS. You can prevent this by setting the "video-timing-offset" global option to 0. (This applies only to "audio" video sync mode.)</p>
<p>You should pass the following parameters:</p><ul>
<li>Backend-specific target object, such as MPV_RENDER_PARAM_OPENGL_FBO.</li>
<li>Possibly transformations, such as MPV_RENDER_PARAM_FLIP_Y.</li>
</ul>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>a valid render context </td></tr>
    <tr><td class="paramname">params</td><td>an array of parameters, terminated by type==0. Which parameters are required depends on the backend. It's left unspecified what happens with unknown parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>error code </dd></dl>

</div>
</div>
<a id="ad92439f8eb565f006cb3982aa88ff095" name="ad92439f8eb565f006cb3982aa88ff095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad92439f8eb565f006cb3982aa88ff095">&#9670;&#160;</a></span>mpv_render_context_report_swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="client_8h.html#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> void mpv_render_context_report_swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae2c9749016fe3762f7e18472ad902ec0">mpv_render_context</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tell the renderer that a frame was flipped at the given time. This is optional, but can help the player to achieve better timing.</p>
<p>Note that calling this at least once informs mpv that you will use this function. If you use it inconsistently, expect bad video playback.</p>
<p>If this is called while no video is initialized, it is ignored.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>a valid render context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a817e67dc0a7a56c13911bbe01627aaaf" name="a817e67dc0a7a56c13911bbe01627aaaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a817e67dc0a7a56c13911bbe01627aaaf">&#9670;&#160;</a></span>mpv_render_context_set_parameter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="client_8h.html#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> int mpv_render_context_set_parameter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae2c9749016fe3762f7e18472ad902ec0">mpv_render_context</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmpv__render__param.html">mpv_render_param</a></td>          <td class="paramname"><span class="paramname"><em>param</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attempt to change a single parameter. Not all backends and parameter types support all kinds of changes.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>a valid render context </td></tr>
    <tr><td class="paramname">param</td><td>the parameter type and data that should be set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>error code. If a parameter could actually be changed, this returns success, otherwise an error code depending on the parameter type and situation. </dd></dl>

</div>
</div>
<a id="ad5d400a7aa5b865545acb5579fa651f7" name="ad5d400a7aa5b865545acb5579fa651f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5d400a7aa5b865545acb5579fa651f7">&#9670;&#160;</a></span>mpv_render_context_set_update_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="client_8h.html#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> void mpv_render_context_set_update_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae2c9749016fe3762f7e18472ad902ec0">mpv_render_context</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aa976582e31273bcea01cd6d862a9a332">mpv_render_update_fn</a></td>          <td class="paramname"><span class="paramname"><em>callback</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>callback_ctx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the callback that notifies you when a new video frame is available, or if the video display configuration somehow changed and requires a redraw. Similar to <a class="el" href="client_8h.html#a54b24fa9076b9c0ca5f988709d20e736">mpv_set_wakeup_callback()</a>, you must not call any mpv API from the callback, and all the other listed restrictions apply (such as not exiting the callback by throwing exceptions).</p>
<p>This can be called from any thread, except from an update callback. In case of the OpenGL backend, no OpenGL state or API is accessed.</p>
<p>Calling this will raise an update callback immediately.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>callback(callback_ctx) is called if the frame should be redrawn </td></tr>
    <tr><td class="paramname">callback_ctx</td><td>opaque argument to the callback </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af52a5374695fa06f98e92b5eb0538e98" name="af52a5374695fa06f98e92b5eb0538e98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af52a5374695fa06f98e92b5eb0538e98">&#9670;&#160;</a></span>mpv_render_context_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="client_8h.html#a645bac051595e752c4527981767d1604">MPV_EXPORT</a> uint64_t mpv_render_context_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae2c9749016fe3762f7e18472ad902ec0">mpv_render_context</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The API user is supposed to call this when the update callback was invoked (like all mpv_render_* functions, this has to happen on the render thread, and <em>not</em> from the update callback itself).</p>
<p>This is optional if MPV_RENDER_PARAM_ADVANCED_CONTROL was not set (default). Otherwise, it's a hard requirement that this is called after each update callback. If multiple update callback happened, and the function could not be called sooner, it's OK to call it once after the last callback.</p>
<p>If an update callback happens during or after this function, the function must be called again at the soonest possible time.</p>
<p>If MPV_RENDER_PARAM_ADVANCED_CONTROL was set, this will do additional work such as allocating textures for the video decoder.</p>
<dl class="section return"><dt>返回</dt><dd>a bitset of mpv_render_update_flag values (i.e. multiple flags are combined with bitwise or). Typically, this will tell the API user what should happen next. E.g. if the MPV_RENDER_UPDATE_FRAME flag is set, <a class="el" href="#ac60a37eba7ff4e48613ecde542ea62c7">mpv_render_context_render()</a> should be called. If flags unknown to the API user are set, or if the return value is 0, nothing needs to be done. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
制作者&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
